idx = (result1[,3]!=result4[,3])
tmp[idx,]
i1 = 3
i2 = 9
Qpmat.c1 = Qpmat
idx1 <- ( Qpmat.c1[i1,] <= cvec )
idx2 <- ( Qpmat.c1[i2,] <= cvec )
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
## thresholding procedure
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec)
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]  ## Qpmat.c2 : symm matrix
Qpmat.c2
Qpmat.c2[c(3,9)]
Qpmat.c2[c(3,9),]
Qpmat.c1 = Qpmat
idx1 <- ( Qpmat.c1[i1,] <= cvec )
idx2 <- ( Qpmat.c1[i2,] <= cvec )
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
## thresholding procedure
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec)
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]
Qpmat.c2
Qpmat[c(3,9)]
Qpmat[c(3,9),]
Qmat[c(3,9),]
i1i2_adj_matrix = matrix(as.integer(Qpmat.c2>0) , p , p)  ## adjacency matrix
i1i2_graph = graph_from_adjacency_matrix(i1i2_adj_matrix ,
mode="undirected" , weighted=NULL)
## make a graph
i1i2_clusters = clusters(i1i2_graph)$mem ## clustering using adj matrix
if (i1i2_clusters[i1] != i1i2_clusters[i2]){
## i1과 i2가 다른 connected 되지 않은 경우
#  cat('   k:',k-1,', ',i1,'and',i2, 'is not connected!!\n')
idx = idx + 1
next
}
## idx3 : edge index set of V_jk
idx3 = sort(which(i1i2_clusters %in% i1i2_clusters[i1]))
idx3
wmat <- Qpmat.c2[idx3,idx3]*Gmat_hat[idx3, idx3]
wmat = t(wmat)
pp <- length(idx3)
wvec = wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
xx = matrix(0, pp*(pp-1), pp)
yy = rep(0, pp*(pp-1) )
ix = 1
for (i in 1:pp)
{
for (j in 1:pp)
{
if (i == j) next
jx1 = min(i,j)
jx2 = max(i,j)
xx[ix,jx1] = 1; xx[ix,jx2] = -1
if (i<j) yy[ix] = 1
ix = ix + 1
}
}
xx = xx[,-pp]
try.fit <- try(fit <- glmnet(xx, yy, family = 'binomial',
intercept = FALSE, weights = wvec,
lambda = 0.0000, alpha = 0, standardize = F,
thresh = 1e-09),
pp <- length(idx3)
wvec = wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
xx = matrix(0, pp*(pp-1), pp)
yy = rep(0, pp*(pp-1) )
ix = 1
for (i in 1:pp)
{
for (j in 1:pp)
{
if (i == j) next
jx1 = min(i,j)
jx2 = max(i,j)
xx[ix,jx1] = 1; xx[ix,jx2] = -1
if (i<j) yy[ix] = 1
ix = ix + 1
}
}
xx = xx[,-pp]
try.fit <- try(fit <- glmnet(xx, yy, family = 'binomial',
intercept = FALSE, weights = wvec,
lambda = 0.0000, alpha = 0, standardize = F,
thresh = 1e-09),
silent = T)
est = c(fit$beta[,1],0)
est
i1
i2
tmp = cbind(result1[,1:2], result1[,3], result4[,3])
idx = (result1[,3]!=result4[,3])
tmp[idx,]
cvec=0
Qmat = Qmat_fit$Qmat
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
sc_list = list()
p = ncol(Qpmat)
idx = 1
result = matrix(0, p*(p-1)/2, 4)
i1 = 1
i2 = 8
Qpmat.c1 = Qpmat
idx1 <- ( Qpmat.c1[i1,] <= cvec )
idx2 <- ( Qpmat.c1[i2,] <= cvec )
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
## thresholding procedure
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec)
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]  ## Qpmat.c2 : symm matrix
# extend graph
#idx3 <- sort( union(intersect( setdiff(1:p, idx1), setdiff(1:p, idx2) ),  c(i1, i2)) )
## find V_jk(maximum connected set)
i1i2_adj_matrix = matrix(as.integer(Qpmat.c2>0) , p , p)  ## adjacency matrix
i1i2_graph = graph_from_adjacency_matrix(i1i2_adj_matrix ,
mode="undirected" , weighted=NULL)
## make a graph
i1i2_clusters = clusters(i1i2_graph)$mem ## clustering using adj matrix
if (i1i2_clusters[i1] != i1i2_clusters[i2]){
## i1과 i2가 다른 connected 되지 않은 경우
#  cat('   k:',k-1,', ',i1,'and',i2, 'is not connected!!\n')
idx = idx + 1
next
}
## idx3 : edge index set of V_jk
idx3 = sort(which(i1i2_clusters %in% i1i2_clusters[i1]))
Gmat_hat
#########################################
## computing gBT estimator
#########################################
Qpmat.c2
#########################################
## computing gBT estimator
#########################################
Qpmat.c2[c(i1,i2),]
#########################################
## computing gBT estimator
#########################################
j1_mat = Qpmat.c2[c(i1,i2),]
j1_mat[1,i2]
j1_mat[1,i2]
a = j1_mat[1,i2]
a1 = j1_mat[1,i2]
j1_mat
j1_mat[1,]
j1_mat[1,]!=0
j1_mat[1,][j1_mat[1,]!=0]
max(j1_mat[1,][j1_mat[1,]!=0])
(a1<a2)
a1 = j1_mat[1,i2]
a2 = max(j1_mat[1,][j1_mat[1,]!=0])
a1
a2
(a1<a2)
j1_mat[1,i2]
Qpmat.c2[i1,i2]
j1_mat = Qpmat.c2[c(i1,i2),]
if (j1_mat[1,i2]!=0)
{
a1 = j1_mat[1,i2]
a2 = max(j1_mat[1,][j1_mat[1,]!=0])
if (a1<a2) Qpmat.c2[i1,i2] = Qpmat.c2[i2,i1] = a2
}
wmat <- Qpmat.c2[idx3,idx3]*Gmat_hat[idx3, idx3]
wmat = t(wmat)
pp <- length(idx3)
wvec = wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
xx = matrix(0, pp*(pp-1), pp)
yy = rep(0, pp*(pp-1) )
ix = 1
for (i in 1:pp)
{
for (j in 1:pp)
{
if (i == j) next
jx1 = min(i,j)
jx2 = max(i,j)
xx[ix,jx1] = 1; xx[ix,jx2] = -1
if (i<j) yy[ix] = 1
ix = ix + 1
}
}
xx = xx[,-pp]
try.fit <- try(fit <- glmnet(xx, yy, family = 'binomial',
intercept = FALSE, weights = wvec,
lambda = 0.0000, alpha = 0, standardize = F,
thresh = 1e-09),
silent = T)
if (class(try.fit)[1] == 'try-error')
{
idx = idx + 1
next
}
est = c(fit$beta[,1],0)
est
i1
i2
## check the naive
# compare the result of SR1 and gBT-pre
tmp = cbind(result1[,1:2], result1[,3], result4[,3])
idx = (result1[,3]!=result4[,3])
tmp[idx,]
cvec=0
Qmat = Qmat_fit$Qmat
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
sc_list = list()
p = ncol(Qpmat)
idx = 1
result = matrix(0, p*(p-1)/2, 4)
i1 = 2
i2 = 11
Qpmat.c1 = Qpmat
idx1 <- ( Qpmat.c1[i1,] <= cvec )
idx2 <- ( Qpmat.c1[i2,] <= cvec )
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
## thresholding procedure
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec)
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]  ## Qpmat.c2 : symm matrix
Qpmat.c1 = Qpmat
idx1 <- ( Qpmat.c1[i1,] <= cvec )
idx2 <- ( Qpmat.c1[i2,] <= cvec )
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
## thresholding procedure
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec)
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]  ## Qpmat.c2 : symm matrix
# extend graph
#idx3 <- sort( union(intersect( setdiff(1:p, idx1), setdiff(1:p, idx2) ),  c(i1, i2)) )
## find V_jk(maximum connected set)
i1i2_adj_matrix = matrix(as.integer(Qpmat.c2>0) , p , p)  ## adjacency matrix
i1i2_graph = graph_from_adjacency_matrix(i1i2_adj_matrix ,
mode="undirected" , weighted=NULL)
## make a graph
i1i2_clusters = clusters(i1i2_graph)$mem ## clustering using adj matrix
if (i1i2_clusters[i1] != i1i2_clusters[i2]){
## i1과 i2가 다른 connected 되지 않은 경우
#  cat('   k:',k-1,', ',i1,'and',i2, 'is not connected!!\n')
idx = idx + 1
next
}
## idx3 : edge index set of V_jk
idx3 = sort(which(i1i2_clusters %in% i1i2_clusters[i1]))
#########################################
## computing gBT estimator
#########################################
j1_mat = Qpmat.c2[c(i1,i2),]
if (j1_mat[1,i2]!=0)
{
a1 = j1_mat[1,i2]
a2 = max(j1_mat[1,][j1_mat[1,]!=0])
if (a1<a2) Qpmat.c2[i1,i2] = Qpmat.c2[i2,i1] = a2
}
wmat <- Qpmat.c2[idx3,idx3]*Gmat_hat[idx3, idx3]
wmat = t(wmat)
pp <- length(idx3)
wvec = wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
xx = matrix(0, pp*(pp-1), pp)
yy = rep(0, pp*(pp-1) )
ix = 1
for (i in 1:pp)
{
for (j in 1:pp)
{
if (i == j) next
jx1 = min(i,j)
jx2 = max(i,j)
xx[ix,jx1] = 1; xx[ix,jx2] = -1
if (i<j) yy[ix] = 1
ix = ix + 1
}
}
xx = xx[,-pp]
try.fit <- try(fit <- glmnet(xx, yy, family = 'binomial',
intercept = FALSE, weights = wvec,
lambda = 0.0000, alpha = 0, standardize = F,
thresh = 1e-09),
silent = T)
if (class(try.fit)[1] == 'try-error')
{
idx = idx + 1
next
}
est = c(fit$beta[,1],0)
est
i1
i2
i1
i2
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
#sel_idx = sel_idx[!sel_idx==8]
#sel_idx = sel_idx[!sel_idx==20]
#sel_idx = sel_idx[!sel_idx==34]
#sel_idx = sel_idx[!sel_idx==38]
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[1])$gbt_est
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
#
set.seed(1)
n = nrow(rdata[,18:33])
s_idx = sample(1:n, trunc(n*0.8))
race_mat <- as.matrix(rdata[s_idx,18:33])
num_vec <- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[2])$gbt_est
race_mat <- as.matrix(rdata[-s_idx,18:33])
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
#sel_idx = sel_idx[!sel_idx==8]
#sel_idx = sel_idx[!sel_idx==20]
#sel_idx = sel_idx[!sel_idx==34]
#sel_idx = sel_idx[!sel_idx==38]
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[1])$gbt_est
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
#
set.seed(1)
n = nrow(rdata[,18:33])
s_idx = sample(1:n, trunc(n*0.8))
race_mat <- as.matrix(rdata[s_idx,18:33])
num_vec <- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[1])$gbt_est
race_mat <- as.matrix(rdata[-s_idx,18:33])
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
#sel_idx = sel_idx[!sel_idx==8]
#sel_idx = sel_idx[!sel_idx==20]
#sel_idx = sel_idx[!sel_idx==34]
#sel_idx = sel_idx[!sel_idx==38]
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[1])$gbt_est
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
Qpmat.c2
Qpmat.c2
Qpmat.c2[i1,i2]
