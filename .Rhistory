'/result/sreal_traninig_', i_1,"_", i_2))
# test procedure
vmat1 = vmat2 = vmat3 = NULL
i = 1
sel_idx.top
cat(i,'\n')
set.seed(i)
s_idx = sample(1:n, trunc(n*0.7))
race_mat <- as.matrix(rdata[-s_idx,18:33])
num_vec <- rdata$V1[-s_idx]
### please note the use of sel_idx or sel_idx.top
### sel_idx.top is used when the full model is used.
Qmat_fit <-QmatFun(race_mat, num_vec, cut_var = 0,
p=43, sel_idx.top)
#gbt_est = gbt_est.list_1_43[[i]][sel_idx.top]
bt_est = rank(bt_est.list[[i]])
bt_est
bt_est
bt_est[sel_idx.top]
# v3 = evalFun_1(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_1(rdata[-s_idx,], sr_est, sel_idx)
# vmat1 = rbind(vmat1, c(v1,v2,v5,v3,v4))
#
# v1 = evalFun_2(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_2(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_2(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_2(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_2(rdata[-s_idx,], sr_est, sel_idx)
# vmat2 = rbind(vmat2, c(v1,v2,v5,v3,v4))
bt_est = bt_est[sel_idx.top]
evalFun_3(Qmat_fit, bt_est)
bt_est = bt_est[sel_idx.top]
evalFun_3(Qmat_fit, gbt_est)
rm(list = ls())
gc()
# training code
# set path
if (Sys.info()[1] == "Linux") {
setwd("/home/jeon/Documents/GitHub/RankConsistency")
} else {
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
}
# load car segmentation
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/real_traninig_', 1,"_", 43))
bt_est.list_1_43 = bt_est.list
gbt_est.list_1_43 = gbt_est.list
gbt_est.list2_1_43 = gbt_est.list2
sr1_est.list_1_43 = sr1_est.list
sr_est.list_1_43 = sr_est.list
load("Real_BT_gBT2_cv5_all_data.rdata")
i_1 = 1
i_2 = 43
sel_idx = which(BT_est_rank >= i_1 & BT_est_rank <= i_2)
sel_idx.top = which(BT_est_rank >= 1 & BT_est_rank <= 13)
plot(BT_est_rank,gBT2_est_rank, pch = 19,
ylab = "ranks of gBT", xlab = "ranks of BT")
ls()
# library
library(MASS)
library(igraph)
library(glmnet)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
sim.num = 50
rdata<-read.csv('racing_data.csv', header=F)
n = nrow(rdata)
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/sreal_traninig_', i_1,"_", i_2))
# test procedure
vmat1 = vmat2 = vmat3 = NULL
i = 1
rm(list = ls())
gc()
# training code
# set path
if (Sys.info()[1] == "Linux") {
setwd("/home/jeon/Documents/GitHub/RankConsistency")
} else {
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
}
# load car segmentation
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/real_traninig_', 1,"_", 43))
bt_est.list_1_43 = bt_est.list
gbt_est.list_1_43 = gbt_est.list
gbt_est.list2_1_43 = gbt_est.list2
sr1_est.list_1_43 = sr1_est.list
sr_est.list_1_43 = sr_est.list
load("Real_BT_gBT2_cv5_all_data.rdata")
i_1 = 1
i_2 = 43
sel_idx = which(BT_est_rank >= i_1 & BT_est_rank <= i_2)
sel_idx.top = which(BT_est_rank >= 1 & BT_est_rank <= 13)
plot(BT_est_rank,gBT2_est_rank, pch = 19,
ylab = "ranks of gBT", xlab = "ranks of BT")
ls()
# library
library(MASS)
library(igraph)
library(glmnet)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
sim.num = 50
rdata<-read.csv('racing_data.csv', header=F)
n = nrow(rdata)
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/sreal_traninig_', i_1,"_", i_2))
# test procedure
vmat1 = vmat2 = vmat3 = NULL
i = 1
cat(i,'\n')
set.seed(i)
s_idx = sample(1:n, trunc(n*0.7))
race_mat <- as.matrix(rdata[-s_idx,18:33])
num_vec <- rdata$V1[-s_idx]
### please note the use of sel_idx or sel_idx.top
### sel_idx.top is used when the full model is used.
Qmat_fit <-QmatFun(race_mat, num_vec, cut_var = 0,
p=43, sel_idx.top)
gbt_est = gbt_est.list[[i]]
if (is.null(gbt_est)) next
#gbt_est = gbt_est.list_1_43[[i]][sel_idx.top]
bt_est = rank(bt_est.list[[i]])
#bt_est = bt_est.list_1_43[[i]][sel_idx.top]
sr_est = sr_est.list[[i]]
#sr_est = sr_est.list_1_43[[i]][sel_idx.top]
sr1_est = sr1_est.list[[i]]
#sr1_est = sr1_est.list_1_43[[i]][sel_idx.top]
gbt2_est = gbt_est.list2[[i]]
sel_idx.top
gbt_est2[sel_idx.top]
gbt2_est[sel_idx.top]
gbt2_est = gbt2_est[sel_idx.top]
evalFun_3(Qmat_fit, gbt2_est)
i = 2
cat(i,'\n')
set.seed(i)
s_idx = sample(1:n, trunc(n*0.7))
race_mat <- as.matrix(rdata[-s_idx,18:33])
num_vec <- rdata$V1[-s_idx]
### please note the use of sel_idx or sel_idx.top
### sel_idx.top is used when the full model is used.
Qmat_fit <-QmatFun(race_mat, num_vec, cut_var = 0,
p=43, sel_idx.top)
gbt_est = gbt_est.list[[i]]
if (is.null(gbt_est)) next
#gbt_est = gbt_est.list_1_43[[i]][sel_idx.top]
bt_est = rank(bt_est.list[[i]])
#bt_est = bt_est.list_1_43[[i]][sel_idx.top]
sr_est = sr_est.list[[i]]
#sr_est = sr_est.list_1_43[[i]][sel_idx.top]
sr1_est = sr1_est.list[[i]]
#sr1_est = sr1_est.list_1_43[[i]][sel_idx.top]
gbt2_est = gbt_est.list2[[i]]
#gbt2_est = gbt_est.list2_1_43[[i]][sel_idx.top]
# v1 = evalFun_1(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_1(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_1(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_1(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_1(rdata[-s_idx,], sr_est, sel_idx)
# vmat1 = rbind(vmat1, c(v1,v2,v5,v3,v4))
#
# v1 = evalFun_2(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_2(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_2(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_2(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_2(rdata[-s_idx,], sr_est, sel_idx)
# vmat2 = rbind(vmat2, c(v1,v2,v5,v3,v4))
#gbt2_est = gbt2_est[sel_idx.top]
gbt2_est = gbt2_est[sel_idx.top]
evalFun_3(Qmat_fit, gbt2_est)
bt_est
bt_est[sel_idx.top]
# v4 = evalFun_1(rdata[-s_idx,], sr_est, sel_idx)
# vmat1 = rbind(vmat1, c(v1,v2,v5,v3,v4))
#
# v1 = evalFun_2(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_2(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_2(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_2(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_2(rdata[-s_idx,], sr_est, sel_idx)
# vmat2 = rbind(vmat2, c(v1,v2,v5,v3,v4))
#gbt2_est = gbt2_est[sel_idx.top]
bt_est = bt_est[sel_idx.top]
evalFun_3(Qmat_fit, bt_est)
rm(list = ls())
gc()
# training code
# set path
if (Sys.info()[1] == "Linux") {
setwd("/home/jeon/Documents/GitHub/RankConsistency")
} else {
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
}
# load car segmentation
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/real_traninig_', 1,"_", 43))
bt_est.list_1_43 = bt_est.list
gbt_est.list_1_43 = gbt_est.list
gbt_est.list2_1_43 = gbt_est.list2
sr1_est.list_1_43 = sr1_est.list
sr_est.list_1_43 = sr_est.list
load("Real_BT_gBT2_cv5_all_data.rdata")
i_1 = 1
i_2 = 43
sel_idx = which(BT_est_rank >= i_1 & BT_est_rank <= i_2)
sel_idx.top = which(BT_est_rank >= 1 & BT_est_rank <= 13)
plot(BT_est_rank,gBT2_est_rank, pch = 19,
ylab = "ranks of gBT", xlab = "ranks of BT")
ls()
# library
library(MASS)
library(igraph)
library(glmnet)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
sim.num = 50
rdata<-read.csv('racing_data.csv', header=F)
n = nrow(rdata)
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/sreal_traninig_', i_1,"_", i_2))
# test procedure
vmat1 = vmat2 = vmat3 = NULL
i = 1
#sel_idx.top = 1:43
for (i in 1:sim.num)
{
cat(i,'\n')
set.seed(i)
s_idx = sample(1:n, trunc(n*0.7))
race_mat <- as.matrix(rdata[-s_idx,18:33])
num_vec <- rdata$V1[-s_idx]
### please note the use of sel_idx or sel_idx.top
### sel_idx.top is used when the full model is used.
Qmat_fit <-QmatFun(race_mat, num_vec, cut_var = 0,
p=43, sel_idx.top)
gbt_est = gbt_est.list[[i]]
if (is.null(gbt_est)) next
#gbt_est = gbt_est.list_1_43[[i]][sel_idx.top]
bt_est = rank(bt_est.list[[i]])
#bt_est = bt_est.list_1_43[[i]][sel_idx.top]
sr_est = sr_est.list[[i]]
#sr_est = sr_est.list_1_43[[i]][sel_idx.top]
sr1_est = sr1_est.list[[i]]
#sr1_est = sr1_est.list_1_43[[i]][sel_idx.top]
gbt2_est = gbt_est.list2[[i]]
#gbt2_est = gbt_est.list2_1_43[[i]][sel_idx.top]
# v1 = evalFun_1(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_1(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_1(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_1(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_1(rdata[-s_idx,], sr_est, sel_idx)
# vmat1 = rbind(vmat1, c(v1,v2,v5,v3,v4))
#
# v1 = evalFun_2(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_2(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_2(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_2(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_2(rdata[-s_idx,], sr_est, sel_idx)
# vmat2 = rbind(vmat2, c(v1,v2,v5,v3,v4))
gbt2_est = gbt2_est[sel_idx.top]
bt_est = bt_est[sel_idx.top]
v1 = evalFun_3(Qmat_fit, bt_est)
v2 = evalFun_3(Qmat_fit, gbt_est)
v5 = evalFun_3(Qmat_fit, gbt2_est)
v3 = evalFun_3(Qmat_fit, sr1_est)
v4 = evalFun_3(Qmat_fit, sr_est)
vmat3 = rbind(vmat3, c(v1,v2,v5,v3,v4))
}
sel_idx.top
rm(list = ls())
gc()
# training code
# set path
if (Sys.info()[1] == "Linux") {
setwd("/home/jeon/Documents/GitHub/RankConsistency")
} else {
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
}
# load car segmentation
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/real_traninig_', 1,"_", 43))
bt_est.list_1_43 = bt_est.list
gbt_est.list_1_43 = gbt_est.list
gbt_est.list2_1_43 = gbt_est.list2
sr1_est.list_1_43 = sr1_est.list
sr_est.list_1_43 = sr_est.list
load("Real_BT_gBT2_cv5_all_data.rdata")
i_1 = 1
i_2 = 43
sel_idx = which(BT_est_rank >= i_1 & BT_est_rank <= i_2)
sel_idx.top = which(BT_est_rank >= 1 & BT_est_rank <= 13)
plot(BT_est_rank,gBT2_est_rank, pch = 19,
ylab = "ranks of gBT", xlab = "ranks of BT")
ls()
# library
library(MASS)
library(igraph)
library(glmnet)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
sim.num = 50
rdata<-read.csv('racing_data.csv', header=F)
n = nrow(rdata)
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/sreal_traninig_', i_1,"_", i_2))
# test procedure
vmat1 = vmat2 = vmat3 = NULL
i = 1
sel_idx.top
cat(i,'\n')
set.seed(i)
s_idx = sample(1:n, trunc(n*0.7))
race_mat <- as.matrix(rdata[-s_idx,18:33])
num_vec <- rdata$V1[-s_idx]
### please note the use of sel_idx or sel_idx.top
### sel_idx.top is used when the full model is used.
Qmat_fit <-QmatFun(race_mat, num_vec, cut_var = 0,
p=43, sel_idx.top)
gbt_est = gbt_est.list[[i]]
if (is.null(gbt_est)) next
#gbt_est = gbt_est.list_1_43[[i]][sel_idx.top]
bt_est = rank(bt_est.list[[i]])
#bt_est = bt_est.list_1_43[[i]][sel_idx.top]
sr_est = sr_est.list[[i]]
#sr_est = sr_est.list_1_43[[i]][sel_idx.top]
sr1_est = sr1_est.list[[i]]
#sr1_est = sr1_est.list_1_43[[i]][sel_idx.top]
gbt2_est = gbt_est.list2[[i]]
#gbt2_est = gbt_est.list2_1_43[[i]][sel_idx.top]
# v1 = evalFun_1(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_1(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_1(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_1(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_1(rdata[-s_idx,], sr_est, sel_idx)
# vmat1 = rbind(vmat1, c(v1,v2,v5,v3,v4))
#
# v1 = evalFun_2(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_2(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_2(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_2(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_2(rdata[-s_idx,], sr_est, sel_idx)
# vmat2 = rbind(vmat2, c(v1,v2,v5,v3,v4))
sel_idx.top
# v3 = evalFun_1(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_1(rdata[-s_idx,], sr_est, sel_idx)
# vmat1 = rbind(vmat1, c(v1,v2,v5,v3,v4))
#
# v1 = evalFun_2(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_2(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_2(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_2(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_2(rdata[-s_idx,], sr_est, sel_idx)
# vmat2 = rbind(vmat2, c(v1,v2,v5,v3,v4))
gbt2_est = gbt2_est[sel_idx.top]
bt_est = bt_est[sel_idx.top]
v1 = evalFun_3(Qmat_fit, bt_est)
v2 = evalFun_3(Qmat_fit, gbt_est)
rm(list = ls())
gc()
# training code
# set path
if (Sys.info()[1] == "Linux") {
setwd("/home/jeon/Documents/GitHub/RankConsistency")
} else {
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
}
# load car segmentation
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/real_traninig_', 1,"_", 43))
bt_est.list_1_43 = bt_est.list
gbt_est.list_1_43 = gbt_est.list
gbt_est.list2_1_43 = gbt_est.list2
sr1_est.list_1_43 = sr1_est.list
sr_est.list_1_43 = sr_est.list
load("Real_BT_gBT2_cv5_all_data.rdata")
i_1 = 1
i_2 = 43
sel_idx = which(BT_est_rank >= i_1 & BT_est_rank <= i_2)
sel_idx.top = which(BT_est_rank >= 1 & BT_est_rank <= 13)
plot(BT_est_rank,gBT2_est_rank, pch = 19,
ylab = "ranks of gBT", xlab = "ranks of BT")
ls()
# library
library(MASS)
library(igraph)
library(glmnet)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
sim.num = 50
rdata<-read.csv('racing_data.csv', header=F)
n = nrow(rdata)
if (Sys.info()[1] == "Linux")
{
restorePath = '/home/jeon/Dropbox/GitHub/RankConsistency'
} else {
restorePath = 'C:/Users/Jeon/Dropbox/GitHub/RankConsistency'
}
load(paste0(restorePath,
'/result/sreal_traninig_', i_1,"_", i_2))
# test procedure
vmat1 = vmat2 = vmat3 = NULL
i = 1
#sel_idx.top = 1:43
for (i in 1:sim.num)
{
cat(i,'\n')
set.seed(i)
s_idx = sample(1:n, trunc(n*0.7))
race_mat <- as.matrix(rdata[-s_idx,18:33])
num_vec <- rdata$V1[-s_idx]
### please note the use of sel_idx or sel_idx.top
### sel_idx.top is used when the full model is used.
Qmat_fit <-QmatFun(race_mat, num_vec, cut_var = 0,
p=43, sel_idx.top)
gbt_est = gbt_est.list[[i]]
if (is.null(gbt_est)) next
#gbt_est = gbt_est.list_1_43[[i]][sel_idx.top]
bt_est = rank(bt_est.list[[i]])
#bt_est = bt_est.list_1_43[[i]][sel_idx.top]
sr_est = sr_est.list[[i]]
#sr_est = sr_est.list_1_43[[i]][sel_idx.top]
sr1_est = sr1_est.list[[i]]
#sr1_est = sr1_est.list_1_43[[i]][sel_idx.top]
gbt2_est = gbt_est.list2[[i]]
#gbt2_est = gbt_est.list2_1_43[[i]][sel_idx.top]
# v1 = evalFun_1(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_1(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_1(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_1(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_1(rdata[-s_idx,], sr_est, sel_idx)
# vmat1 = rbind(vmat1, c(v1,v2,v5,v3,v4))
#
# v1 = evalFun_2(rdata[-s_idx,], bt_est, sel_idx)
# v2 = evalFun_2(rdata[-s_idx,], gbt_est, sel_idx)
# v5 = evalFun_2(rdata[-s_idx,], gbt2_est, sel_idx)
# v3 = evalFun_2(rdata[-s_idx,], sr1_est, sel_idx)
# v4 = evalFun_2(rdata[-s_idx,], sr_est, sel_idx)
# vmat2 = rbind(vmat2, c(v1,v2,v5,v3,v4))
gbt2_est = gbt2_est[sel_idx.top]
bt_est = bt_est[sel_idx.top]
v1 = evalFun_3(Qmat_fit, bt_est)
#v2 = evalFun_3(Qmat_fit, gbt_est)
v2 = evalFun_3(Qmat_fit, gbt2_est)
vmat3 = rbind(vmat3, c(v1,v2))
}
colMeans(vmat3)
