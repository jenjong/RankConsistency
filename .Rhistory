perform_bkendall[i,1] <-  balFun(obs_cars, bt_est, Qpmat)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
perform_gkendall[i,2] <-  dcgFun(rank_hat)
perform_bkendall[i,2] <-  balFun(obs_cars, gbt_est, Qpmat)
# SR
rank_hat  <- order( sr_est[obs_cars], decreasing = T)
#perform_kendall[i,3] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,3] <- kenFun(obs_cars, sr_est)
perform_gkendall[i,3] <-  dcgFun(rank_hat)
perform_bkendall[i,3] <-  balFun(obs_cars, sr_est, Qpmat)
}
k1[seed_v_i,] = apply(perform_kendall,2,mean, na.rm = TRUE)
k2[seed_v_i,] = apply(perform_gkendall,2, mean, na.rm = TRUE)
k3[seed_v_i,] = apply(perform_bkendall,2, mean, na.rm = TRUE)
}
boxplot(k2[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
#
# 1. load the list of coefficients from real_0421.rdata
# 2. there are bt and gbt estimators in result_list$naive and
#     result_list$gbt
# 3.
# function: dcgFun()
rm(list = ls())
gc()
setwd("C:/Users/jeon/Documents/GitHub/RankConsistency")
load("real_0421-sc.Rdata")
result_list_sc = result_list
load("real_0421.rdata")
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
rdata<-read.csv('racing_data.csv', header=F)
min_vec_kendall<- read.csv("min_vec_kendall.csv")
min_vec<- min_vec_kendall$x
seed_v = 1
inner_iter = 100
file_idx = 1
k1 = matrix(0,inner_iter,3)
k2 = matrix(0,inner_iter,3)
k3 = matrix(0,inner_iter,3)
for ( seed_v in 1:inner_iter)
{
cat("iteration::", seed_v, '\n')
seed_v_i = (file_idx -1)*inner_iter + seed_v
set.seed(seed_v_i)
sample_idx <- sort( sample(1:nrow(rdata), trunc(nrow(rdata)*0.8)))
race_mat_test<- as.matrix(rdata[-sample_idx,18:33])
num_vec_test <- rdata$V1[-sample_idx]
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
Qpmat = Qmat_fit$Qpmat
gbt_est <-result_list$gbt[[seed_v]]$gbt_est_mat[min_vec[seed_v],]
bt_est <- result_list$naive[[seed_v]]
sr_est <- result_list_sc$sc_est[[seed_v]]
perform_kendall = matrix(0,length(num_vec_test),3)
perform_gkendall = matrix(0,length(num_vec_test),3)
perform_bkendall = matrix(0,length(num_vec_test),3)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
perform_gkendall[i,1] <-  dcgFun(rank_hat)
perform_bkendall[i,1] <-  balFun(obs_cars, bt_est, Qpmat)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
perform_gkendall[i,2] <-  dcgFun(rank_hat)
perform_bkendall[i,2] <-  balFun(obs_cars, gbt_est, Qpmat)
# SR
rank_hat  <- order( sr_est[obs_cars], decreasing = T)
#perform_kendall[i,3] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,3] <- kenFun(obs_cars, sr_est)
perform_gkendall[i,3] <-  dcgFun(rank_hat)
perform_bkendall[i,3] <-  balFun(obs_cars, sr_est, Qpmat)
}
k1[seed_v_i,] = apply(perform_kendall,2,mean, na.rm = TRUE)
k2[seed_v_i,] = apply(perform_gkendall,2, mean, na.rm = TRUE)
k3[seed_v_i,] = apply(perform_bkendall,2, mean, na.rm = TRUE)
}
k2
boxplot(k2[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
dcgFun
boxplot(k3[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
#
# 1. load the list of coefficients from real_0421.rdata
# 2. there are bt and gbt estimators in result_list$naive and
#     result_list$gbt
# 3.
# function: dcgFun()
rm(list = ls())
gc()
setwd("C:/Users/jeon/Documents/GitHub/RankConsistency")
load("real_0421-sc.Rdata")
result_list_sc = result_list
load("real_0421.rdata")
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
rdata<-read.csv('racing_data.csv', header=F)
min_vec_kendall<- read.csv("min_vec_kendall.csv")
min_vec<- min_vec_kendall$x
seed_v = 1
inner_iter = 100
file_idx = 1
k1 = matrix(0,inner_iter,3)
k2 = matrix(0,inner_iter,3)
k3 = matrix(0,inner_iter,3)
for ( seed_v in 1:inner_iter)
{
cat("iteration::", seed_v, '\n')
seed_v_i = (file_idx -1)*inner_iter + seed_v
set.seed(seed_v_i)
sample_idx <- sort( sample(1:nrow(rdata), trunc(nrow(rdata)*0.8)))
race_mat_test<- as.matrix(rdata[-sample_idx,18:33])
num_vec_test <- rdata$V1[-sample_idx]
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
Qpmat = Qmat_fit$Qpmat
gbt_est <-result_list$gbt[[seed_v]]$gbt_est_mat[min_vec[seed_v],]
bt_est <- result_list$naive[[seed_v]]
sr_est <- result_list_sc$sc_est[[seed_v]]
perform_kendall = matrix(0,length(num_vec_test),3)
perform_gkendall = matrix(0,length(num_vec_test),3)
perform_bkendall = matrix(0,length(num_vec_test),3)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
perform_gkendall[i,1] <-  dcgFun(rank_hat)
perform_bkendall[i,1] <-  balFun(obs_cars, bt_est, Qpmat)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
perform_gkendall[i,2] <-  dcgFun(rank_hat)
perform_bkendall[i,2] <-  balFun(obs_cars, gbt_est, Qpmat)
# SR
rank_hat  <- order( sr_est[obs_cars], decreasing = T)
#perform_kendall[i,3] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,3] <- kenFun(obs_cars, sr_est)
perform_gkendall[i,3] <-  dcgFun(rank_hat)
perform_bkendall[i,3] <-  balFun(obs_cars, sr_est, Qpmat)
}
k1[seed_v_i,] = apply(perform_kendall,2,mean, na.rm = TRUE)
k2[seed_v_i,] = apply(perform_gkendall,2, mean, na.rm = TRUE)
k3[seed_v_i,] = apply(perform_bkendall,2, mean, na.rm = TRUE)
}
boxplot(k2[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
boxplot(k2[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
#
# 1. load the list of coefficients from real_0421.rdata
# 2. there are bt and gbt estimators in result_list$naive and
#     result_list$gbt
# 3.
# function: dcgFun()
rm(list = ls())
gc()
setwd("C:/Users/jeon/Documents/GitHub/RankConsistency")
load("real_0421-sc.Rdata")
result_list_sc = result_list
load("real_0421.rdata")
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
rdata<-read.csv('racing_data.csv', header=F)
min_vec_kendall<- read.csv("min_vec_kendall.csv")
min_vec<- min_vec_kendall$x
seed_v = 1
inner_iter = 100
file_idx = 1
k1 = matrix(0,inner_iter,3)
k2 = matrix(0,inner_iter,3)
k3 = matrix(0,inner_iter,3)
for ( seed_v in 1:inner_iter)
{
cat("iteration::", seed_v, '\n')
seed_v_i = (file_idx -1)*inner_iter + seed_v
set.seed(seed_v_i)
sample_idx <- sort( sample(1:nrow(rdata), trunc(nrow(rdata)*0.8)))
race_mat_test<- as.matrix(rdata[-sample_idx,18:33])
num_vec_test <- rdata$V1[-sample_idx]
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
Qpmat = Qmat_fit$Qpmat
gbt_est <-result_list$gbt[[seed_v]]$gbt_est_mat[min_vec[seed_v],]
bt_est <- result_list$naive[[seed_v]]
sr_est <- result_list_sc$sc_est[[seed_v]]
perform_kendall = matrix(0,length(num_vec_test),3)
perform_gkendall = matrix(0,length(num_vec_test),3)
perform_bkendall = matrix(0,length(num_vec_test),3)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
perform_gkendall[i,1] <-  dcgFun(rank_hat)
perform_bkendall[i,1] <-  balFun(obs_cars, bt_est, Qpmat)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
perform_gkendall[i,2] <-  dcgFun(rank_hat)
perform_bkendall[i,2] <-  balFun(obs_cars, gbt_est, Qpmat)
# SR
rank_hat  <- order( sr_est[obs_cars], decreasing = T)
#perform_kendall[i,3] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,3] <- kenFun(obs_cars, sr_est)
perform_gkendall[i,3] <-  dcgFun(rank_hat)
perform_bkendall[i,3] <-  balFun(obs_cars, sr_est, Qpmat)
}
k1[seed_v_i,] = apply(perform_kendall,2,mean, na.rm = TRUE)
k2[seed_v_i,] = apply(perform_gkendall,2, mean, na.rm = TRUE)
k3[seed_v_i,] = apply(perform_bkendall,2, mean, na.rm = TRUE)
}
boxplot(k2[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
pi
1 + 1/log(2)
1 + 1/log(2) - 1/log(3)
#
# 1. load the list of coefficients from real_0421.rdata
# 2. there are bt and gbt estimators in result_list$naive and
#     result_list$gbt
# 3.
# function: dcgFun()
rm(list = ls())
gc()
setwd("C:/Users/jeon/Documents/GitHub/RankConsistency")
load("real_0421-sc.Rdata")
result_list_sc = result_list
load("real_0421.rdata")
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
rdata<-read.csv('racing_data.csv', header=F)
min_vec_kendall<- read.csv("min_vec_kendall.csv")
min_vec<- min_vec_kendall$x
seed_v = 1
inner_iter = 100
file_idx = 1
k1 = matrix(0,inner_iter,3)
k2 = matrix(0,inner_iter,3)
k3 = matrix(0,inner_iter,3)
for ( seed_v in 1:inner_iter)
{
cat("iteration::", seed_v, '\n')
seed_v_i = (file_idx -1)*inner_iter + seed_v
set.seed(seed_v_i)
sample_idx <- sort( sample(1:nrow(rdata), trunc(nrow(rdata)*0.8)))
race_mat_test<- as.matrix(rdata[-sample_idx,18:33])
num_vec_test <- rdata$V1[-sample_idx]
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
Qpmat = Qmat_fit$Qpmat
gbt_est <-result_list$gbt[[seed_v]]$gbt_est_mat[min_vec[seed_v],]
bt_est <- result_list$naive[[seed_v]]
sr_est <- result_list_sc$sc_est[[seed_v]]
perform_kendall = matrix(0,length(num_vec_test),3)
perform_gkendall = matrix(0,length(num_vec_test),3)
perform_bkendall = matrix(0,length(num_vec_test),3)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
perform_gkendall[i,1] <-  dcgFun(rank_hat)
perform_bkendall[i,1] <-  balFun(obs_cars, bt_est, Qpmat)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
perform_gkendall[i,2] <-  dcgFun(rank_hat)
perform_bkendall[i,2] <-  balFun(obs_cars, gbt_est, Qpmat)
# SR
rank_hat  <- order( sr_est[obs_cars], decreasing = T)
#perform_kendall[i,3] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,3] <- kenFun(obs_cars, sr_est)
perform_gkendall[i,3] <-  dcgFun(rank_hat)
perform_bkendall[i,3] <-  balFun(obs_cars, sr_est, Qpmat)
}
k1[seed_v_i,] = apply(perform_kendall,2,mean, na.rm = TRUE)
k2[seed_v_i,] = apply(perform_gkendall,2, mean, na.rm = TRUE)
k3[seed_v_i,] = apply(perform_bkendall,2, mean, na.rm = TRUE)
}
boxplot(k2[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
#
# 1. load the list of coefficients from real_0421.rdata
# 2. there are bt and gbt estimators in result_list$naive and
#     result_list$gbt
# 3.
# function: dcgFun()
rm(list = ls())
gc()
setwd("C:/Users/jeon/Documents/GitHub/RankConsistency")
load("real_0421-sc.Rdata")
result_list_sc = result_list
load("real_0421.rdata")
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
rdata<-read.csv('racing_data.csv', header=F)
min_vec_kendall<- read.csv("min_vec_kendall.csv")
min_vec<- min_vec_kendall$x
seed_v = 1
inner_iter = 100
file_idx = 1
k1 = matrix(0,inner_iter,3)
k2 = matrix(0,inner_iter,3)
k3 = matrix(0,inner_iter,3)
for ( seed_v in 1:inner_iter)
{
cat("iteration::", seed_v, '\n')
seed_v_i = (file_idx -1)*inner_iter + seed_v
set.seed(seed_v_i)
sample_idx <- sort( sample(1:nrow(rdata), trunc(nrow(rdata)*0.8)))
race_mat_test<- as.matrix(rdata[-sample_idx,18:33])
num_vec_test <- rdata$V1[-sample_idx]
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
Qpmat = Qmat_fit$Qpmat
gbt_est <-result_list$gbt[[seed_v]]$gbt_est_mat[min_vec[seed_v],]
bt_est <- result_list$naive[[seed_v]]
sr_est <- result_list_sc$sc_est[[seed_v]]
perform_kendall = matrix(0,length(num_vec_test),3)
perform_gkendall = matrix(0,length(num_vec_test),3)
perform_bkendall = matrix(0,length(num_vec_test),3)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
perform_gkendall[i,1] <-  dcgFun(rank_hat)
perform_bkendall[i,1] <-  balFun(obs_cars, bt_est, Qpmat)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
perform_gkendall[i,2] <-  dcgFun(rank_hat)
perform_bkendall[i,2] <-  balFun(obs_cars, gbt_est, Qpmat)
# SR
rank_hat  <- order( sr_est[obs_cars], decreasing = T)
#perform_kendall[i,3] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,3] <- kenFun(obs_cars, sr_est)
perform_gkendall[i,3] <-  dcgFun(rank_hat)
perform_bkendall[i,3] <-  balFun(obs_cars, sr_est, Qpmat)
}
k1[seed_v_i,] = apply(perform_kendall,2,mean, na.rm = TRUE)
k2[seed_v_i,] = apply(perform_gkendall,2, mean, na.rm = TRUE)
k3[seed_v_i,] = apply(perform_bkendall,2, mean, na.rm = TRUE)
}
boxplot(k2[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
k2
k1
seed_v = 13
result_list$naive[[seed_v]]
bt_est <- result_list$naive[[seed_v]]
sr_est <- result_list_sc$sc_est[[seed_v]]
gbt_est <-result_list$gbt[[seed_v]]$gbt_est_mat[min_vec[seed_v],]
gbt_est
bt_est <- result_list$naive[[seed_v]]
sr_est <- result_list_sc$sc_est[[seed_v]]
plot(bt_est, gbt_est)
plot(rank(bt_est), rank(gbt_est))
plot(rank(bt_est) - rank(gbt_est)
)
k1[,2] -k1[,1]
mean(k1[,2] -k1[,1])
sum(k1[,2] -k1[,1]>0)
dcgFun
boxplot(k3[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "generalized rank distance")
boxplot(k2[,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
idx = k1[,1] > k1[,2]
boxplot(k1[idx,c(2,1,3)], col = 'lightblue',
names = c("gBT", "BT", "SC"),
ylab = "kendall's rank distance")
rm(list = ls())
gc()
#setwd("C:/Users/Jeon/Documents/GitHub/RankConsistency")
setwd("C:/Users/uos_stat/Documents/GitHub/RankConsistency")
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
max_k = 4
cvec_r <- seq(0, max_k, by = 2)
file_idx = 1
inner_iter = 500
seed_v = 1
result_matrix_kendall = matrix(0,inner_iter, length(cvec_r)+1)
result_matrix_DCG = matrix(0,inner_iter, length(cvec_r)+1)
result_list = list()
result_list$naive = vector(mode = 'list', length = inner_iter)
result_list$gbt = vector(mode = 'list', length = inner_iter)
cat("iteration::", seed_v, '\n')
seed_v_i = (file_idx -1)*inner_iter + seed_v
set.seed(seed_v_i)
sc_list = vector(mode ='list', length = max_k)
## 논문에 나온대로 7:3으로 뽑음.
sample_idx <- sort( sample(1:nrow(rdata), trunc(nrow(rdata)*0.8)))
# cross validation : 여기서 sample 다시 생성해야 함!
race_mat <- as.matrix(rdata[sample_idx,18:33])   ## train set의 각 게임당 선택 차종
num_vec<- rdata$V1[sample_idx]  ## 각 게임마다 참여한 유저 수
Qmat_fit <-QmatFunc(race_mat, num_vec)
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
x = Qmat_fit$x
y = Qmat_fit$y
n = Qmat_fit$n
######## naive BT fit
naive_est <- naive_btFunc(x,y, Qpmat, Gmat_hat)
result_list$naive[[seed_v]] <-  naive_est
cvec <- cvec_r/n*2 ## cvec : threshold c vector
sc_list <- sc_listFun(cvec, Qpmat, Gmat_hat)
sc_list[[1]]
gbt_eval
sc_list[[1]]
sc_list[[1]][,1]
sc_list[[1]][,1]==0
which(sc_list[[1]][,1])
sc_list[[2]]
?glmnet
length(sc_list)
sc_list[[1]]
sc_list[[1]]
pmat <-sc_list[[1]]
dim(pmat)
43*42/2
ix = 0
for (j in 1:42)
{
for (k in (j+1):43)
{
ix = ix + 1
}
}
ix
ix = 1
win_mat = matrix(0,43,43)
for (j in 1:42)
{
for (k in (j+1):43)
{
if (pmat[ix,1]==0)
{
win_mat[j,k] =  win_mat[k,j] =  0.5
}
if (pmat[ix,1]!=0)
{
win_mat[j,k] = pmat[ix,3]
win_mat[k,j] = 1-pmat[ix,3]
}
ix = ix + 1
}
}
win_mat
apply(win_mat,1,sum)
rank(apply(win_mat,1,sum))
43-rank(apply(win_mat,1,sum))
