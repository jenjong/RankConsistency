FH = pop_min$cov
beta_tilde = pop_min$est
s = (FH[1,1] + FH[2,2] - 2*FH[1,2])
m = beta_tilde[1] - beta_tilde[2]
rankcons.prob = c()
for (j in 1:length(nvec))
{
rankcons.prob[j] = 1- pnorm(0, m, sqrt(s)/sqrt(nvec[j]))
}
rankcons.mat = rbind(rankcons.mat, rankcons.prob)
}
rownames(rankcons.mat) = NULL
colnames(rankcons.mat) = nvec
rownames(rankcons.mat) = gamma.vec
library(ggplot2)
library(reshape)
rmat = rankcons.mat
#lim.v = 0.3
#rmat[rmat<=lim.v]  = lim.v
fig <- ggplot(melt(rmat), aes(x = X1, y = X2, z = value,fill = value))+
geom_tile()  +  scale_fill_gradientn(colours = heat.colors(500))
print(fig)
# image(x = gamma.vec, y = nvec, rankcons.mat, ylab = 'n', xlab = 'gamma',
#       useRaster = TRUE)
# numerical simulations
n = 100
iter = 1
iter.num = 1000
beta_mat = NULL
for (iter in 1:iter.num)
{
Gmat_hat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = alpha*n
if ( (i == 1 & j == 4) ) un = alpha*n
if ((i==3) & (j==4)) un = alpha*n
v = mean( ( (rt(un,df) + lambda.vec[i]) -
(rt(un,df) + lambda.vec[j])  ) >0 )
Gmat_hat[i,j] = v
Gmat_hat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
}
}
# set an intial parameter for btFUN
Qpmat = Qmat/sum(Qmat)
Qmat_fit$Qpmat = Qpmat
Qmat_fit$Gmat_hat = Gmat_hat
Qmat_fit$x = x
Qmat_fit$y = y
# fit the BT
beta_hat = btFun(Qmat_fit)
beta_mat = rbind(beta_mat, beta_hat)
}
mean(beta_mat[,1] - beta_mat[,2]>0)
sd(beta_mat[,1] - beta_mat[,2])
abline(h = 0)
# numerical simulations : compute bias for each sample size
gamma.v
iter = 1
iter.num = 1000
beta_mat = NULL
for (iter in 1:iter.num)
{
Gmat_hat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = alpha*n
if ( (i == 1 & j == 4) ) un = alpha*n
if ((i==3) & (j==4)) un = alpha*n
v = mean( ( (rt(un,df) + lambda.vec[i]) -
(rt(un,df) + lambda.vec[j])  ) >0 )
Gmat_hat[i,j] = v
Gmat_hat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
}
}
# set an intial parameter for btFUN
Qpmat = matrix(1,p,p)
Qmat_fit$Qpmat = Qpmat
Qmat_fit$Gmat_hat = Gmat_hat
Qmat_fit$x = x
Qmat_fit$y = y
# fit the BT
beta_hat = btFun(Qmat_fit)
beta_mat = rbind(beta_mat, beta_hat)
}
boxplot(beta_mat[,1] - beta_mat[,2])
abline(h = 0)
cov.list[[1]]
cov.list[[10]]
cov.list[[20]]
cov.list[[60]]
cov.list[[80]]
cov.list[[90]]
cov.list[[100]]
mean(beta_mat[,1] - beta_mat[,2]>0)
Qpmat
beta_tilde
beta_tilde
Qmat
sum(Qmat)
# numerical simulations
n = 10
iter.num = 1000
iter = 1
Gmat_hat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = alpha*n
if ( (i == 1 & j == 4) ) un = alpha*n
if ((i==3) & (j==4)) un = alpha*n
v = mean( ( (rt(un,df) + lambda.vec[i]) -
(rt(un,df) + lambda.vec[j])  ) >0 )
Gmat_hat[i,j] = v
Gmat_hat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
}
}
Qmat
sum(Qmat)
n = 2
iter = 1
iter.num = 1000
beta_mat = NULL
Gmat_hat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = alpha*n
if ( (i == 1 & j == 4) ) un = alpha*n
if ((i==3) & (j==4)) un = alpha*n
v = mean( ( (rt(un,df) + lambda.vec[i]) -
(rt(un,df) + lambda.vec[j])  ) >0 )
Gmat_hat[i,j] = v
Gmat_hat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
}
}
sum(Qmat)
n = 2
iter = 1
iter.num = 1000
beta_mat = NULL
for (iter in 1:iter.num)
{
Gmat_hat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = alpha*n
if ( (i == 1 & j == 4) ) un = alpha*n
if ((i==3) & (j==4)) un = alpha*n
v = mean( ( (rt(un,df) + lambda.vec[i]) -
(rt(un,df) + lambda.vec[j])  ) >0 )
Gmat_hat[i,j] = v
Gmat_hat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
}
}
# set an intial parameter for btFUN
Qpmat = Qmat/sum(Qmat)
Qmat_fit$Qpmat = Qpmat
Qmat_fit$Gmat_hat = Gmat_hat
Qmat_fit$x = x
Qmat_fit$y = y
# fit the BT
beta_hat = btFun(Qmat_fit)
beta_mat = rbind(beta_mat, beta_hat)
}
mean(beta_mat[,1] - beta_mat[,2]>0)
Qmat
Qpmat
0.77
0.77+0.3
mean(beta_mat[,1] - beta_mat[,2]>0)
rmat
dim(rmat)
rmat[,50]
rmat[50,]
nvec[50]
nvec]
nvec
rmat[20,]
mean(beta_mat[,1] - beta_mat[,2]>0)
Qmat
dum(Qmat)
sum(Qmat)
Qmat
rmat[1,]
Qpmat
rmat[50,]
dim(rmat)
rmat[101,]
Qpmat
iter = 1
iter.num = 1000
beta_mat = NULL
for (iter in 1:iter.num)
{
Gmat_hat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = alpha*n
if ( (i == 1 & j == 4) ) un = alpha*n
if ((i==3) & (j==4)) un = alpha*n
v = mean( ( (rt(un,df) + lambda.vec[i]) -
(rt(un,df) + lambda.vec[j])  ) >0 )
Gmat_hat[i,j] = v
Gmat_hat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
}
}
# set an intial parameter for btFUN
Qpmat = matrix(1,p,p)
Qmat_fit$Qpmat = Qpmat
Qmat_fit$Gmat_hat = Gmat_hat
Qmat_fit$x = x
Qmat_fit$y = y
# fit the BT
beta_hat = btFun(Qmat_fit)
beta_mat = rbind(beta_mat, beta_hat)
}
mean(beta_mat[,1] - beta_mat[,2]>0)
rmat[20,]
boxplot(beta_mat[,1] - beta_mat[,2])
abline(h = 0)
Qmat
# population minimizer
# inverstigation of asymptotic variances
rm (list =ls()); gc()
setwd("C:/Users/Jeon/Documents/GitHub/RankConsistency")
library(e1071)
library(quadprog)
library(MASS)
library(igraph)
library(glmnet)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
# set parameters in simulation
nvec = seq(50,500,by = 10)
gamma.vec = seq(0,1,by = 0.01)
df = 1 ;     alpha = 20
lambda.vec = c(1.2,1.1,0.6,0)*4
pop_beta_mat = NULL
rankcons.mat = NULL
cov.list = list()
for (iter in 1:length(gamma.vec))
{
gamma.v = gamma.vec[iter]
pop_min = list()
{
p = length(lambda.vec)
idx = 1
Gmat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = 1
if ( (i == 2 & j == 3) ) un = alpha
if ( (i == 1 & j == 4) ) un = alpha
if ((i==3) & (j==4)) un = alpha
tmp.vec = rep(0,p)
tmp.vec[i] = 1 ; tmp.vec[j] = -1
v = pt((lambda.vec[i]- lambda.vec[j])/2, df = df)
#v = plogis((lambda.vec[i]- lambda.vec[j]))
Gmat[i,j] = v
Gmat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
idx = idx + 1
}
}
# set up Qpmat
Qpmat = Qmat/sum(Qmat)*2
# set up (x,y) : complete comparisons
x = matrix(0, p*(p-1), p)
y = rep(0, p*(p-1) )
ix = 1
for (i in 1:p)
{
for (j in 1:p)
{
if (i == j) next
jx1 = min(i,j)
jx2 = max(i,j)
x[ix,jx1] = 1; x[ix,jx2] = -1
if (i<j) y[ix] = 1
ix = ix + 1
}
}
x = x[,-p]
Qmat_fit = list()
Qmat_fit$Qpmat = Qpmat
Qmat_fit$Gmat_hat = Gmat
Qmat_fit$x = x
Qmat_fit$y = y
# population minimizer
bt_data = Qmat_fit
Qpmat = bt_data$Qpmat
wmat = (1/Qpmat)^gamma.v ; diag(wmat) = 0
bt_data$Qpmat = Qpmat*wmat
beta_tilde = btFun(bt_data)
pop_beta_mat = rbind(pop_beta_mat, beta_tilde)
pop_min$est = beta_tilde
# true probability
true_prob = Gmat
# variance of score function
v_s = matrix(0,p-1,p-1)
# diag
for ( i in 1:(p-1))
{
v_s[i,i] = sum(true_prob[i,-i]*(1-true_prob[i,-i])*Qpmat[i,-i]*
wmat[i,-i]^2)
}
# off-diag
for ( i in 1:(p-1))
{
for (j in 1:(p-1))
{
if (i==j) next
v_s[i,j] = - true_prob[i,j]*(1-true_prob[i,j])*Qpmat[i,j]*
wmat[i,j]^2
}
}
# estimated probability
est_prob = matrix(0,p,p)
for (i in 1:p)
{
for (j in 1:p)
{
if (i==j) next
v = exp(beta_tilde[i]-beta_tilde[j])
est_prob[i,j] = v/(1+v)
}
}
# Hessian
H = matrix(0,p-1,p-1)
# diag
for ( i in 1:(p-1))
{
H[i,i] = sum(est_prob[i,-i]*(1-est_prob[i,-i])*Qpmat[i,-i]*
wmat[i,-i])
}
# off-diag
for ( i in 1:(p-1))
{
for (j in 1:(p-1))
{
if (i==j) next
H[i,j] = - est_prob[i,j]*(1-est_prob[i,j])*Qpmat[i,j]*
wmat[i,j]
}
}
# Asymptotic variance
FH = solve(H)%*%v_s%*%solve(H)
pop_min$cov = FH
cov.list[[iter]] = FH
}
FH = pop_min$cov
beta_tilde = pop_min$est
s = (FH[1,1] + FH[2,2] - 2*FH[1,2])
m = beta_tilde[1] - beta_tilde[2]
rankcons.prob = c()
for (j in 1:length(nvec))
{
rankcons.prob[j] = 1- pnorm(0, m, sqrt(s)/sqrt(nvec[j]))
}
rankcons.mat = rbind(rankcons.mat, rankcons.prob)
}
rownames(rankcons.mat) = NULL
colnames(rankcons.mat) = nvec
rownames(rankcons.mat) = gamma.vec
library(ggplot2)
library(reshape)
rmat = rankcons.mat
#lim.v = 0.3
#rmat[rmat<=lim.v]  = lim.v
fig <- ggplot(melt(rmat), aes(x = X1, y = X2, z = value,fill = value))+
geom_tile()  +  scale_fill_gradientn(colours = heat.colors(500))
print(fig)
# image(x = gamma.vec, y = nvec, rankcons.mat, ylab = 'n', xlab = 'gamma',
#       useRaster = TRUE)
# numerical simulations
n = 2
iter = 1
iter.num = 1000
beta_mat = NULL
for (iter in 1:iter.num)
{
Gmat_hat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = alpha*n
if ( (i == 1 & j == 4) ) un = alpha*n
if ((i==3) & (j==4)) un = alpha*n
v = mean( ( (rt(un,df) + lambda.vec[i]) -
(rt(un,df) + lambda.vec[j])  ) >0 )
Gmat_hat[i,j] = v
Gmat_hat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
}
}
# set an intial parameter for btFUN
Qpmat = Qmat/sum(Qmat)
Qmat_fit$Qpmat = Qpmat
Qmat_fit$Gmat_hat = Gmat_hat
Qmat_fit$x = x
Qmat_fit$y = y
# fit the BT
beta_hat = btFun(Qmat_fit)
beta_mat = rbind(beta_mat, beta_hat)
}
mean(beta_mat[,1] - beta_mat[,2]>0)
sd(beta_mat[,1] - beta_mat[,2])
abline(h = 0)
rmat[1,]
Qmat
sum(Qmat)
sum(Qmat)/2
mean(beta_mat[,1] - beta_mat[,2]>0)
n = 4
iter = 1
iter.num = 1000
beta_mat = NULL
for (iter in 1:iter.num)
{
Gmat_hat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = alpha*n
if ( (i == 1 & j == 4) ) un = alpha*n
if ((i==3) & (j==4)) un = alpha*n
v = mean( ( (rt(un,df) + lambda.vec[i]) -
(rt(un,df) + lambda.vec[j])  ) >0 )
Gmat_hat[i,j] = v
Gmat_hat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
}
}
# set an intial parameter for btFUN
Qpmat = Qmat/sum(Qmat)
Qmat_fit$Qpmat = Qpmat
Qmat_fit$Gmat_hat = Gmat_hat
Qmat_fit$x = x
Qmat_fit$y = y
# fit the BT
beta_hat = btFun(Qmat_fit)
beta_mat = rbind(beta_mat, beta_hat)
}
sum(Qmat)/2
mean(beta_mat[,1] - beta_mat[,2]>0)
rmat[1,]
n = 6
iter = 1
iter.num = 1000
beta_mat = NULL
for (iter in 1:iter.num)
{
Gmat_hat = Qmat = matrix(0,p,p)
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = alpha*n
if ( (i == 1 & j == 4) ) un = alpha*n
if ((i==3) & (j==4)) un = alpha*n
v = mean( ( (rt(un,df) + lambda.vec[i]) -
(rt(un,df) + lambda.vec[j])  ) >0 )
Gmat_hat[i,j] = v
Gmat_hat[j,i] = 1-v
Qmat[i,j] = Qmat[j,i] = un
}
}
# set an intial parameter for btFUN
Qpmat = Qmat/sum(Qmat)
Qmat_fit$Qpmat = Qpmat
Qmat_fit$Gmat_hat = Gmat_hat
Qmat_fit$x = x
Qmat_fit$y = y
# fit the BT
beta_hat = btFun(Qmat_fit)
beta_mat = rbind(beta_mat, beta_hat)
}
sum(Qmat)/2
mean(beta_mat[,1] - beta_mat[,2]>0)
rmat[1,]
