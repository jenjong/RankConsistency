method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.01, maxiter=1000)
plot(Z%*%fit$root[-(1:3)])
##### theta, beta MLE
lambda = 0
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.001, maxiter=1000)
plot(Z%*%fit$root[-(1:3)])
fit
##### theta, beta MLE
lambda = 0.1
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.001, maxiter=1000)
fit
plot(Z%*%fit$root[-(1:3)])
##### theta, beta MLE
lambda = 0.01
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.001, maxiter=1000)
fit
plot(Z%*%fit$root[-(1:3)])
##### theta, beta MLE
lambda = 0.01
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.001, maxiter=2000)
fit
plot(Z%*%fit$root[-(1:3)])
##### theta, beta MLE
lambda = 0.01
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=2000)
fit
plot(Z%*%fit$root[-(1:3)])
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=100)
fit
plot(Z%*%fit$root[-(1:3)])
GEV_regfull <- function (x, z, theta0, beta0, expr=expr_reg,
method = c('linear', 'B-spline'),
Om = NULL, lambda = 0,
alpha=1, maxiter = 1000, tol = 1e-05) {
n = length(x)
old_theta <- c(theta0,beta0)
#if (method == 'B-spline' ) old_theta[1] = 0
new_theta <- old_theta
niter <- 0
Jaco <- expr$Jaco
Hmat <- expr$Hmat
# if the spline is used, the intercept is not updated for identifiability
for (i in 1:maxiter)
{
niter = niter + 1
mu = c(old_theta[1]+z%*%old_theta[-(1:3)])
s  = old_theta[2]
k  = old_theta[3]
grad = apply(cbind(eval(Jaco),eval(Jaco)[,1]*z),2,mean)
if (method == 'B-spline' )
{
grad[-(1:3)] = grad[-(1:3)] + 2*lambda*Om%*%old_theta[-(1:3)]
grad = grad[-1]
}
if (max(abs(grad))<1e-4){
break
}
hess = GEVhessian(x,z,mu,s,k)
hess = hess + diag(1e-8, ncol(hess))
if (method == 'B-spline' )
{
#new_theta = old_theta - alpha*grad
hess[-(1:3),-(1:3)] = hess[-(1:3),-(1:3)] + 2*lambda*Om*n
hess = hess[-1,-1]
gd = -solve(hess)%*%grad
new_theta[-1] = old_theta[-1] + alpha*gd
# if (new_theta[3]>0)
# {
#   # check alpha
#   if (new_theta[2] < 0 )  stop ("alpha is unstable ")
#   # check mu and kappa
#   mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
#   lx = (min(x) <= mu.i - new_theta[2]/new_theta[3])
#   if (any(lx))  stop ("mu and kappa is unstable")
# }
#
# if (new_theta[3]<0)
# {
#   # check alpha
#   if (new_theta[2] < 0 )  stop ("alpha is unstable")
#   # check mu and kappa
#   mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
#   lx = (max(x) >= mu.i - new_theta[2]/new_theta[3])
#   if (any(lx))  stop ("mu and kappa is unstable")
# }
}
if (method == 'linear' )
{
new_theta = old_theta - alpha*solve(hess)%*%grad
}
old_theta = new_theta
}
return(list(initial = theta0, root = c(old_theta), step = niter))
}
##### theta, beta MLE
lambda = 0.01
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=100)
fit
plot(Z%*%fit$root[-(1:3)])
##### theta, beta MLE
lambda = 0.01
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=1000)
fit
plot(Z%*%fit$root[-(1:3)])
fit$root[1]+Z%*%fit$root[-(1:3)]
plot(x,Y)
Y
plot(Y)
lines(fit$root[1]+Z%*%fit$root[-(1:3)])
lambda = 0.1
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=1000)
fit$
plot(Z%*%fit$root[-(1:3)])
plot(Y)
lines(fit$root[1]+Z%*%fit$root[-(1:3)])
lambda = 1
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=1000)
#fit$
#plot(Z%*%fit$root[-(1:3)])
plot(Y)
lines(fit$root[1]+Z%*%fit$root[-(1:3)])
#
solve(t(Z)%*%Z + lambda*diag(1, ncol(Z)))%*%t(Z)%*%Y
#
Z%*%solve(t(Z)%*%Z + lambda*diag(1, ncol(Z)))%*%t(Z)%*%Y
#
plot(Z%*%solve(t(Z)%*%Z + lambda*diag(1, ncol(Z)))%*%t(Z)%*%Y)
lambda
#
plot(Z%*%solve(t(Z)%*%Z + n*lambda*diag(1, ncol(Z)))%*%t(Z)%*%Y)
#
lambda = 0.1
plot(Z%*%solve(t(Z)%*%Z + n*lambda*diag(1, ncol(Z)))%*%t(Z)%*%Y)
#
lambda = 0.1
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 1
plot(Z%*%solve(t(Z)%*%Z + lambda*Om)%*%t(Z)%*%Y)
#
lambda = 10
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 100
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 1000
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 10
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 1100
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 10
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 1
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
plot(Y)
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
plot(v)
#
lambda = 1
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
plot(v)
#
lambda = 100
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
plot(v)
#
lambda = 1000
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
plot(v)
plot(Y)
#
lambda = 1000
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 100
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 10
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
lambda = 1
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=1000)
plot(Z%*%fit$root[-(1:3)])
##### theta, beta MLE
lambda = 0.1
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=1000)
plot(Z%*%fit$root[-(1:3)])
plot(Y)
s = 2
sim.iter = 100
lambda_vec = seq(0, 1, length  = 50)
#for ( s in c(1:sim.iter) ) {
set.seed(s)
eps = rgev(n,loc=true_theta[1], scale=true_theta[2], shape=true_theta[3])
Y = true_beta + eps
##### theta, beta MLE
lambda = 0.1
plot(Y)
lines(fit$root[1]+Z%*%fit$root[-(1:3)])
#
lambda = 10
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 100
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
Y
#
lambda = 1000
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 10000
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
Y
##### theta, beta MLE
lambda = 0.1
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=1000)
plot(Y)
plot(Z%*%fit$root[-(1:3)])
s = 3
#for ( s in c(1:sim.iter) ) {
set.seed(s)
eps = rgev(n,loc=true_theta[1], scale=true_theta[2], shape=true_theta[3])
Y = true_beta + eps
##### theta, beta MLE
lambda = 0.1
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=1000)
plot(Z%*%fit$root[-(1:3)])
plot(Y)
lines(fit$root[1]+Z%*%fit$root[-(1:3)])
#
lambda = 10000
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
#
lambda = 1000
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
Y
#
lambda = 100
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
Y
#
lambda = 10
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
Y
##### theta, beta MLE
lambda = 0.1
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=1000)
#fit$
plot(Z%*%fit$root[-(1:3)])
##### theta, beta MLE
lambda = 0.01
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.1, maxiter=1000)
#fit$
plot(Z%*%fit$root[-(1:3)])
#
lambda = 10
plot(Z%*%solve(t(Z)%*%Z + n*lambda*Om)%*%t(Z)%*%Y)
Om
library(raster)
getwd()
setwd("~")
getwd()
fn <- "srtm_62_04/srtm_62_04.tif"
r1 <- raster(fn)
plot(r1)
str(r1)
r1@data@values[1]
r1@data@values
r1@data@band
r1@crs@projargs
names(r1)
slot(r1)
slots(r1)
slot(r1)
r1@z
r1@extent
str(r1@extent)
attr(r1)
str(fn)
r1 <- raster(fn)
plot(r1)
r1$s
r1$x
str(r1)
r1$z
r1@z
View(z)
rm(list = ls())
library(raster)
setwd("~")
fn <- "srtm_62_04/srtm_62_04.tif"
r1 <- raster(fn)
plot(r1)
str(r1)
inMemory((r1))
values(r1)[1:10]
values(r1)[1:1000]
dim(r1)
values(r1)[1:100,1:100]
values(r1)[1:100,1:100,1]
res(r1)
rm (list =ls()); gc()
library(e1071)
library(quadprog)
setwd("C:/Users/Jeon/Documents/GitHub/RankConsistency")
source("./lib/lib_rank.r")
n=200 ; df = 1
lambda.vec = c(1.2,1.1,0.6,0)*4
p = length(lambda.vec)
alpha.vec = 1:20
num.iter = 100
beta.mat1 = beta.mat2  = NULL
rank.mat1 = rank.mat2 = NULL
set.seed(1)
k = 1
alpha = alpha.vec[k]
alpha
tmp.mat1 = tmp.mat2 = NULL
for ( iter in 1:100)
{
X = NULL
pij = c()
true.prob = c()
idx = 1
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = n*alpha
if ( (i == 1 & j == 4) ) un = n*alpha
if ((i==3) & (j==4)) un=n*alpha
tmp.vec = rep(0,p)
tmp.vec[i] = 1 ; tmp.vec[j] = -1
X = rbind(X, tmp.vec)
true.prob[idx] = mean( ( (rt(un,df) + lambda.vec[i]) - (rt(un,df) + lambda.vec[j])  ) >0 )
#          true.prob[idx]=pt(lambda.vec[i]-lambda.vec[j],1)
pij[idx] = un
idx = idx + 1
}
}
# orginal Bradley-Terry model
X = X[,-p] ; pij = pij/ sum(pij)
beta.vec = IWLS.ridge(X,true.prob,pij,accuracy=10e-10,maxitration=200)
beta.vec = c(beta.vec,0)
tmp.mat1 = rbind(tmp.mat1,beta.vec)
beta.vec = pIWLS(X,true.prob,pij,accuracy=10e-10,maxitration=200)
tmp.mat2 = rbind(tmp.mat2,beta.vec)
}
beta.mat1 = rbind(beta.mat1, colMeans(tmp.mat1))
beta.mat1
beta.mat2 = rbind(beta.mat2, colMeans(tmp.mat2))
beta.mat2
rank.mat1 = rbind(rank.mat1, colMeans(rank.fun(tmp.mat1,p)))
rank.mat2 = rbind(rank.mat2, colMeans(rank.fun(tmp.mat2,p)))
rank.mat1
rank.mat2
rm (list =ls()); gc()
library(e1071)
library(quadprog)
setwd("C:/Users/Jeon/Documents/GitHub/RankConsistency")
source("./lib/lib_rank.r")
#source('D:\\JJJ\\ranking problem\\Jeon-2014-03-05 order consistency\\experiment\\library\\lib_rank.r')
n=200 ; df = 1
lambda.vec = c(1.2,1.1,0.6,0)*4
p = length(lambda.vec)
alpha.vec = 1:20
num.iter = 100
beta.mat1 = beta.mat2  = NULL
rank.mat1 = rank.mat2 = NULL
set.seed(1)
for (k in 1:length(alpha.vec))
{
alpha = alpha.vec[k]
tmp.mat1 = tmp.mat2 = NULL
for ( iter in 1:100)
{
X = NULL
pij = c()
true.prob = c()
idx = 1
for (i in 1:(p-1) )
{
for (j in (i+1):p)
{
un = n
if ( (i == 2 & j == 3) ) un = n*alpha
if ( (i == 1 & j == 4) ) un = n*alpha
if ((i==3) & (j==4)) un=n*alpha
tmp.vec = rep(0,p)
tmp.vec[i] = 1 ; tmp.vec[j] = -1
X = rbind(X, tmp.vec)
true.prob[idx] = mean( ( (rt(un,df) + lambda.vec[i]) - (rt(un,df) + lambda.vec[j])  ) >0 )
#          true.prob[idx]=pt(lambda.vec[i]-lambda.vec[j],1)
pij[idx] = un
idx = idx + 1
}
}
# orginal Bradley-Terry model
X = X[,-p] ; pij = pij/ sum(pij)
beta.vec = IWLS.ridge(X,true.prob,pij,accuracy=10e-10,maxitration=200)
beta.vec = c(beta.vec,0)
tmp.mat1 = rbind(tmp.mat1,beta.vec)
beta.vec = pIWLS(X,true.prob,pij,accuracy=10e-10,maxitration=200)
tmp.mat2 = rbind(tmp.mat2,beta.vec)
#        rownames(X) = NULL
#        m = svm(mX,my, kernel='linear', scale = F, cost = 0.5)
#        w <- t(m$coefs) %*% X[m$index,]
#        w = c(w,0)
#        w
#        cat(beta.vec,'\n')
}
beta.mat1 = rbind(beta.mat1, colMeans(tmp.mat1))
beta.mat2 = rbind(beta.mat2, colMeans(tmp.mat2))
rank.mat1 = rbind(rank.mat1, colMeans(rank.fun(tmp.mat1,p)))
rank.mat2 = rbind(rank.mat2, colMeans(rank.fun(tmp.mat2,p)))
}
plot(alpha.vec, rank.mat1[,1], type = 'b', lty = 1, ylim = c(0,4.2),
ylab = "averages of estimated ranks", xlab = expression(gamma),
main = 'BT',
pch = 20, cex.lab = 1.5, cex.axis = 1.3)
lines(alpha.vec, rank.mat1[,2], lty = 1,type = 'b', pch = 2)
lines(alpha.vec, rank.mat1[,3], lty = 1, type = 'b',pch = 3)
lines(alpha.vec, rank.mat1[,4], lty = 1, type = 'b',pch = 4)
legend('bottomright', legend = c(expression(paste(lambda[1], "     ")),
expression(lambda[2]),
expression(lambda[3]),
expression(lambda[4])),
pch = c(20, 2,3,4), lty = c(1,1,1,1) )
plot(alpha.vec, rank.mat2[,1], type = 'b', lty = 1, ylim = c(0,4.2),
ylab = "averages of estimated ranks", xlab = expression(gamma),
main = 'gBT',
pch = 20, cex.lab = 1.5, cex.axis = 1.3)
lines(alpha.vec, rank.mat2[,2], lty = 1,type = 'b', pch = 2)
lines(alpha.vec, rank.mat2[,3], lty = 1, type = 'b',pch = 3)
lines(alpha.vec, rank.mat2[,4], lty = 1, type = 'b',pch = 4)
legend('bottomright', legend = c(expression(paste(lambda[1], "     ")),
expression(lambda[2]),
expression(lambda[3]),
expression(lambda[4])),
pch = c(20, 2,3,4), lty = c(1,1,1,1) )
