fit<-glmnet(x,y, family = 'binomial', lambda = 0.000001)
gbt_est <- c(fit$beta[,1],0)
names(gbt_est) = colnames(Qpmat)
gbt_estmat = rbind(gbt_estmat, gbt_est)
}
return( list(sc_list = sc_list, gbt_estmat = gbt_estmat) )
}
sc_listFun(Qmat_fit)
gbtFun <-function(Qmat_fit, cvec=0)
{
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
sc_list = list()
p = ncol(Qpmat)
for ( k in 1:length(cvec))
{
#cat('thershold::', k-1, '\n')
i1 = 1 ; i2 = 2
idx = 1
result = matrix(0, p*(p-1)/2, 4)
for ( i1 in 1:(p-1))
{
for (i2 in (i1+1):p)
{
Qpmat.c1 = Qpmat
idx1 <- ( Qpmat.c1[i1,] <= cvec[k] )
idx2 <- ( Qpmat.c1[i2,] <= cvec[k] )
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
## thresholding procedure
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec[k])
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]  ## Qpmat.c2 : symm matrix
#idx3 <- sort( union(intersect( setdiff(1:p, idx1), setdiff(1:p, idx2) ),  c(i1, i2)) )
## find V_jk(maximum connected set)
i1i2_adj_matrix = matrix(as.integer(Qpmat.c2>0) , p , p)  ## adjacency matrix
i1i2_graph = graph_from_adjacency_matrix(i1i2_adj_matrix ,
mode="undirected" , weighted=NULL) ## make a graph
i1i2_clusters = clusters(i1i2_graph)$mem ## clustering using adj matrix
if (i1i2_clusters[i1] != i1i2_clusters[i2]){  ## i1과 i2가 다른 connected 되지 않은 경우
#  cat('   k:',k-1,', ',i1,'and',i2, 'is not connected!!\n')
idx = idx + 1
next
}
## idx3 : edge index set of V_jk
idx3 = sort(which(i1i2_clusters %in% i1i2_clusters[i1]))
#########################################
## computing gBT estimator
#########################################
wmat <- Qpmat.c2[idx3,idx3]*Gmat_hat[idx3, idx3]
wmat = t(wmat)
pp <- length(idx3)
wvec = wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
xx = matrix(0, pp*(pp-1), pp)
yy = rep(0, pp*(pp-1) )
ix = 1
for (i in 1:pp)
{
for (j in 1:pp)
{
if (i == j) next
jx1 = min(i,j)
jx2 = max(i,j)
xx[ix,jx1] = 1; xx[ix,jx2] = -1
if (i<j) yy[ix] = 1
ix = ix + 1
}
}
xx = xx[,-pp]
try.fit <- try(fit <- glmnet(xx, yy, family = 'binomial',
intercept = FALSE, weights = wvec,
lambda = 0.0001, alpha = 0, standardize = F,
thresh = 1e-09),
silent = T)
if (class(try.fit)[1] == 'try-error')
{
idx = idx + 1
next
}
est = c(fit$beta[,1],0)
result[idx, 1:2] = c(i1, i2)
if( est[which(idx3==i1)] > est[which(idx3==i2)]) result[idx, 3] = 1
idx = idx + 1
}
}
sc_list[[k]] <- result
}
gbt_estmat = NULL
for (k in 1:length(cvec))
{
tmp<-sc_list[[k]]
tmp <-tmp[tmp[,1]!=0, 1:3]
p_set <-unique(c(tmp[,1:2]))
if (length(p_set) != p)
{
gbt_est = NULL
next
}
x <- matrix(0, nrow(tmp)*2, p)
y <- rep(0, nrow(tmp)*2)
for ( i in 1:nrow(tmp))
{
vec1<-tmp[i,1:2]; vec2<- tmp[i,3]
x[2*(i-1)+1, vec1] <- c(1,-1) ; y[2*(i-1)+1] <- vec2
x[2*i, vec1] <- c(-1,1) ; y[2*i] <- abs(vec2 - 1)
}
x<- x[,-p]
fit<-glmnet(x,y, family = 'binomial', lambda = 0.000001)
gbt_est <- c(fit$beta[,1],0)
names(gbt_est) = colnames(Qpmat)
gbt_estmat = rbind(gbt_estmat, gbt_est)
}
return( list(sc_list = sc_list, gbt_estmat = gbt_estmat) )
}
gbtFun(Qmat_fit)
gbtFun(Qmat_fit)
gbtFun(Qmat_fit)$gbt_estmat
naive_est
gbt_est <- gbtFun(Qmat_fit)$gbt_estmat
gbt_est
bt_est <- naive_btFunc(Qmat_fit)
bt_est <- btFunc(Qmat_fit)
btFunc<- function(Qmat_fit)
{
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
x = Qmat_fit$x
y = Qmat_fit$y
p = ncol(Qpmat)
wmat = Qpmat*Gmat_hat
wmat = t(wmat)
wvec = wmat[ - (1 + ( 0:(p-1) ) *(p+1))]  ## w_jj 제거
# fit glmnet
fit <- glmnet(x, y, family = 'binomial',
intercept = FALSE, weights = wvec, lambda = 0,
standardize = F,
thresh = 1e-09)
est = c(fit$beta[,1],0) ## lambda_43 추가
naive_est <- est
names(naive_est) = colnames(Qpmat)
return( naive_est )
}
btFun<- function(Qmat_fit)
{
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
x = Qmat_fit$x
y = Qmat_fit$y
p = ncol(Qpmat)
wmat = Qpmat*Gmat_hat
wmat = t(wmat)
wvec = wmat[ - (1 + ( 0:(p-1) ) *(p+1))]  ## w_jj 제거
# fit glmnet
fit <- glmnet(x, y, family = 'binomial',
intercept = FALSE, weights = wvec, lambda = 0,
standardize = F,
thresh = 1e-09)
est = c(fit$beta[,1],0) ## lambda_43 추가
naive_est <- est
names(naive_est) = colnames(Qpmat)
return( naive_est )
}
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
max_k = 0
cvec_r <- 0
sc_list = vector(mode ='list', length = max_k)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFunc(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
gbt_est <- gbtFun(Qmat_fit)$gbt_estmat
bt_est
gbt_est
est = bt_est
est
rankest <- length(est) - rank(est) + 1
i = 1
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_cars
rank_true <- 1:length(obs_cars)
rank_true
order( est[obs_cars], decreasing = T)
est[obs_cars]
obs_cars
est
obs_cars
est[obs_cars]
obs_cars
obs_cars
1:length(obs_cars)
est
obs_cars
names(est)
sel_idx
sel_idx
obs_cars
obs_cars
sel_idx
obs_cars %in% sel_idx
obs_cars %in% sel_idx
obs_cars %in% sel_idx
obs_idx = obs_cars %in% sel_idx
sum(obs_idx)
i = 1
for (i in 1:length(num_vec))
{
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
if ( sum(obs_idx) >2 ) break
}
obs_cars
obs_idx
obs_idx
obs_cars[obs_idx]
obs_cars <- obs_cars[obs_idx]
match(obs_cars, sel_idx)
sel_idx
est[match(obs_cars, sel_idx)]
cor(1:length(obs_cars),
est[match(obs_cars, sel_idx)], method = 'kendall')
est[match(obs_cars, sel_idx)]
1- cor(1:length(obs_cars),
est[match(obs_cars, sel_idx)], method = 'kendall')
(1- cor(1:length(obs_cars),
est[match(obs_cars, sel_idx)], method = 'kendall'))/2
i = 1
for (i in 1:length(num_vec))
{
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
if ( sum(obs_idx) >2 ) break
obs_cars <- obs_cars[obs_idx]
perform_v[i] = (1- cor(1:length(obs_cars),
est[match(obs_cars, sel_idx)], method = 'kendall'))/2
}
i
i = 1
obs_cars
i = 1
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_cars
obs_idx = obs_cars %in% sel_idx
i = 1
for (i in 1:length(num_vec))
{
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
if ( sum(obs_idx) >2 ) next
obs_cars <- obs_cars[obs_idx]
perform_v[i] = (1- cor(1:length(obs_cars),
est[match(obs_cars, sel_idx)], method = 'kendall'))/2
}
i
obs_cars
obs_idx
sum(obs_idx)
i = 1
for (i in 1:length(num_vec))
{
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
if ( sum(obs_idx) < 2 ) next
obs_cars <- obs_cars[obs_idx]
perform_v[i] = (1- cor(1:length(obs_cars),
est[match(obs_cars, sel_idx)], method = 'kendall'))/2
}
perform_v <- rep(0, length(num_vec))
tmp = names(est)
i = 1
for (i in 1:length(num_vec))
{
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
if ( sum(obs_idx) < 2 ) next
obs_cars <- obs_cars[obs_idx]
perform_v[i] = (1- cor(1:length(obs_cars),
est[match(obs_cars, sel_idx)], method = 'kendall'))/2
}
warnings()
cor(1,1, method = 'kendall')
cor(1:2,1:2, method = 'kendall')
perform_v
est[match(obs_cars, sel_idx)]
i = 1
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
obs_idx
( sum(obs_idx) < 2 )
i 665
i = 665
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
obs_idx
obs_cars <- obs_cars[obs_idx]
obs_cars
sel_idx
match(obs_cars, sel_idx)
est[match(obs_cars, sel_idx)]
rank(est[match(obs_cars, sel_idx)])
?rank
rank(est[match(obs_cars, sel_idx)], "min")
rank(est[match(obs_cars, sel_idx)], ties.method = "min")
rank(est[match(obs_cars, sel_idx)], ties.method = "max")
est[match(obs_cars, sel_idx)]
rankest = est[match(obs_cars, sel_idx)]
rankest
rankest = rank( est[match(obs_cars, sel_idx)], ties.method = "max")
rankest = rank( est[match(obs_cars, sel_idx)], ties.method = "max")
rankest
est[match(obs_cars, sel_idx)]
length(obs_cars):1
cor(length(obs_cars):1,
est[match(obs_cars, sel_idx)], method = 'kendall'))
cor(length(obs_cars):1,
rankest, method = 'kendall'))
rankest
cor(length(obs_cars):1,rankest, method = 'kendall')
(1- cor(length(obs_cars):1,rankest, method = 'kendall'))/2
perform_v <- rep(NA, length(num_vec))
tmp = names(est)
i = 1
for (i in 1:length(num_vec))
{
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
if ( sum(obs_idx) < 2 ) next
obs_cars <- obs_cars[obs_idx]
rankest = rank( est[match(obs_cars, sel_idx)], ties.method = "max")
perform_v[i] = (1- cor(length(obs_cars):1,rankest, method = 'kendall'))/2
}
warnings()
perform_v
hist(perform_v)
cor(1,1)
cor(c(1,1),c(1,1))
obs_cars
unique(obs_cars)
perform_v <- rep(NA, length(num_vec))
tmp = names(est)
i = 1
for (i in 1:length(num_vec))
{
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
if ( sum(obs_idx) < 2 ) next
obs_cars <- obs_cars[obs_idx]
if (length(unique(obs_cars)) <2) next
rankest = rank( est[match(obs_cars, sel_idx)], ties.method = "max")
perform_v[i] = (1- cor(length(obs_cars):1,rankest, method = 'kendall'))/2
}
perform_v
cor(length(obs_cars):1,rankest, method = 'kendall')
length(obs_cars):1
rankest
i
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
( sum(obs_idx) < 2 )
mean(perform_v)
mean(perform_v, na.rm = T)
evalFun_1 <- function(rdata, est, sel_idx)
{
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
perform_v <- rep(NA, length(num_vec))
tmp = names(est)
i = 1
for (i in 1:length(num_vec))
{
obs_cars <- race_mat[i,][1:num_vec[i]]
obs_idx = obs_cars %in% sel_idx
if ( sum(obs_idx) < 2 ) next
obs_cars <- obs_cars[obs_idx]
if (length(unique(obs_cars)) <2) next
rankest = rank( est[match(obs_cars, sel_idx)], ties.method = "max")
perform_v[i] = (1- cor(length(obs_cars):1,rankest, method = 'kendall'))/2
}
mean(perform_v, na.rm = T)
}
evalFun_1
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
max_k = 0
cvec_r <- 0
sc_list = vector(mode ='list', length = max_k)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
gbt_est <- gbtFun(Qmat_fit)$gbt_estmat
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
max_k = 0
cvec_r <- 0
sc_list = vector(mode ='list', length = max_k)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
gbt_est <- gbtFun(Qmat_fit)$gbt_estmat
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
sel_idx = 1:43
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
gbt_est <- gbtFun(Qmat_fit)$gbt_estmat
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
gbt_est <- gbtFun(Qmat_fit)$gbt_estmat
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
max_k = 0
cvec_r <- 0
sc_list = vector(mode ='list', length = max_k)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
gbt_est <- gbtFun(Qmat_fit)$gbt_estmat
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
