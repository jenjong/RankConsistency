apply(Qmat[gbt_est.dupCar,gbt_est.dupCar],1,sum)
#fit = apply(Qmat,1,sum)[gbt_est.dupCar]
fit = apply(Qmat[gbt_est.dupCar,gbt_est.dupCar],1,sum)
gbt_est.dupCar
order(fit, decreasing = T)
gbt_est.dupRank[i]
length(gbt_est.dupRank)
gbt_est.dupRank
length(gbt_est.dupCar)
(gbt_est.dupRank[i]+ length(gbt_est.dupCar)-1):(gbt_est.dupRank[i])
gbt_est.dupCar
fit
gbt_est.dupCar.mat
gbt_est.dupCar.assingRank
gbtFun_recov = function(result, Qmat_fit, method = 'binomial',
allowties = FALSE)
{
sc_list <- result
Qmat = Qmat_fit$Qmat
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
p = ncol(Qpmat)
if (method == "count")
{
mat = matrix(0,p,p);
for (i in 1:nrow(result))
{
j = result[i,1];
k = result[i,2];
w_jk = result[i,3];
if (j == 0)
{
mat[j,k] = 0.5;
mat[k,j] = 0.5;
next;
}
if (w_jk==1) mat[j,k] = 1  else mat[k,j] = 1;
}
gbt_est = apply(mat,1,sum);
gbt_est = gbt_est.copy = rank(gbt_est, ties = 'max')
gbt_est.unique = unique(gbt_est)
if (!allowties & length(gbt_est.unique) != p)
{
gbt_est.table = table(gbt_est)
gbt_est.table.names= names(gbt_est.table)
gbt_est.dupRank =
as.integer(gbt_est.table.names[which(gbt_est.table>=2)])
for (i in 1:length(gbt_est.dupRank))
{
gbt_est.dupCar = which(gbt_est == gbt_est.dupRank[i])
# gbt_est.dupCar is always sorted by which function
gbt_est.dupCar.mat = pair_fun(gbt_est.dupCar)
for (j in 1:nrow(gbt_est.dupCar.mat))
{
j1 = gbt_est.dupCar.mat[j,1]
j2 = gbt_est.dupCar.mat[j,2]
idx = result[,1]==j1 & result[,2]==j2
if (any(idx))
{
if (result[idx,3] == 0) gbt_est.dupCar.mat[j,] = c(j2, j1)
} else {
gbt_est.dupCar.mat[j,] = NA
next
}
}
gbt_est.dupCar.mat = gbt_est.dupCar.mat[!is.na(gbt_est.dupCar.mat[,1]),,drop = FALSE]
gbt_est.dupCar.mat = matrix(as.character(gbt_est.dupCar.mat),,ncol(gbt_est.dupCar.mat))
gbt_est.dupCar.dgraph = make_graph(edges = t(gbt_est.dupCar.mat))
# more coding
if (is_dag(gbt_est.dupCar.dgraph))
{
fit = topo_sort(gbt_est.dupCar.dgraph)
gbt_est.dupCar.irank = as.integer(names(fit))
} else {
#fit = apply(Qmat,1,sum)[gbt_est.dupCar]
fit = apply(Qmat[gbt_est.dupCar,gbt_est.dupCar],1,sum)
gbt_est.dupCar.irank = gbt_est.dupCar[order(fit, decreasing = T)]
}
gbt_est.dupCar.assingRank =
(gbt_est.dupRank[i]+ length(gbt_est.dupCar)-1):(gbt_est.dupRank[i])
gbt_est.copy[gbt_est.dupCar] =
gbt_est.dupCar.assingRank[match(gbt_est.dupCar.irank, gbt_est.dupCar)]
}
}
return( gbt_est = gbt_est.copy )
}
gbt_est = NULL
tmp<-sc_list
tmp <-tmp[tmp[,1]!=0, 1:4]
p_set <-unique(c(tmp[,1:2]))
if (length(p_set) != p)
{
gbt_est = NULL
cat('gbt_est is NULL!')
return( gbt_est )
}
x <- matrix(0, nrow(tmp)*2, p)
y <- rep(0, nrow(tmp)*2)
for ( i in 1:nrow(tmp))
{
vec1<-tmp[i,1:2]; vec2<- tmp[i,3]
x[2*(i-1)+1, vec1] <- c(1,-1) ; y[2*(i-1)+1] <- vec2
x[2*i, vec1] <- c(-1,1) ; y[2*i] <- abs(vec2 - 1)
}
x<- x[,-p]
w = rep(tmp[,4], each = 2)
fit<-glmnet(x,y, weights = w, family = method, lambda = 0)
gbt_est <- c(fit$beta[,1],0)
names(gbt_est) = colnames(Qpmat)
return(gbt_est)
}
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
#sel_idx = sel_idx[!sel_idx==8]
#sel_idx = sel_idx[!sel_idx==20]
#sel_idx = sel_idx[!sel_idx==34]
#sel_idx = sel_idx[!sel_idx==38]
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
# estimation
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_fit <- gbtFun(Qmat_fit, cut_v = 0, ctype = 'balance')
result = gbt_fit$sc_list
gbt_est = gbtFun_recov(result, Qmat_fit, method = 'count', allowties = F)
# evaluation
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3_pair(gbt_fit$sc_list, Qmat_fit)
evalFun_3_pair(sr1_fun(Qmat_fit), Qmat_fit)
evalFun_3_pair(sr2_fun(Qmat_fit), Qmat_fit)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
result = sr1_fun(Qmat_fit)
sr1_est = gbtFun_recov(result, Qmat_fit, method='count', allowties = F)
sr1_est
gbtFun_recov(result, Qmat_fit, method='count', allowties = T)
sc_list <- result
Qmat = Qmat_fit$Qmat
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
p = ncol(Qpmat)
if (method == "count")
{
mat = matrix(0,p,p);
for (i in 1:nrow(result))
{
j = result[i,1];
k = result[i,2];
w_jk = result[i,3];
if (j == 0)
{
mat[j,k] = 0.5;
mat[k,j] = 0.5;
next;
}
if (w_jk==1) mat[j,k] = 1  else mat[k,j] = 1;
}
gbt_est = apply(mat,1,sum);
gbt_est = gbt_est.copy = rank(gbt_est, ties = 'max')
mat = matrix(0,p,p);
for (i in 1:nrow(result))
{
j = result[i,1];
k = result[i,2];
w_jk = result[i,3];
if (j == 0)
{
mat[j,k] = 0.5;
mat[k,j] = 0.5;
next;
}
if (w_jk==1) mat[j,k] = 1  else mat[k,j] = 1;
}
gbt_est = apply(mat,1,sum);
gbt_est = gbt_est.copy = rank(gbt_est, ties = 'max')
gbt_est
gbtFun_recov = function(result, Qmat_fit, method = 'binomial',
allowties = FALSE)
{
sc_list <- result
Qmat = Qmat_fit$Qmat
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
p = ncol(Qpmat)
if (method == "count")
{
mat = matrix(0,p,p);
for (i in 1:nrow(result))
{
j = result[i,1];
k = result[i,2];
w_jk = result[i,3];
if (j == 0)
{
mat[j,k] = 0.5;
mat[k,j] = 0.5;
next;
}
if (w_jk==1) mat[j,k] = 1  else mat[k,j] = 1;
}
gbt_est = apply(mat,1,sum);
gbt_est = gbt_est.copy = rank(gbt_est, ties = 'max')
gbt_est.unique = unique(gbt_est)
if (!allowties & length(gbt_est.unique) != p)
{
gbt_est.table = table(gbt_est)
gbt_est.table.names= names(gbt_est.table)
gbt_est.dupRank =
as.integer(gbt_est.table.names[which(gbt_est.table>=2)])
for (i in 1:length(gbt_est.dupRank))
{
gbt_est.dupCar = which(gbt_est == gbt_est.dupRank[i])
# gbt_est.dupCar is always sorted by which function
gbt_est.dupCar.mat = pair_fun(gbt_est.dupCar)
for (j in 1:nrow(gbt_est.dupCar.mat))
{
j1 = gbt_est.dupCar.mat[j,1]
j2 = gbt_est.dupCar.mat[j,2]
idx = result[,1]==j1 & result[,2]==j2
if (any(idx))
{
if (result[idx,3] == 0) gbt_est.dupCar.mat[j,] = c(j2, j1)
} else {
gbt_est.dupCar.mat[j,] = NA
next
}
}
gbt_est.dupCar.mat = gbt_est.dupCar.mat[!is.na(gbt_est.dupCar.mat[,1]),,drop = FALSE]
gbt_est.dupCar.mat = matrix(as.character(gbt_est.dupCar.mat),,ncol(gbt_est.dupCar.mat))
gbt_est.dupCar.dgraph = make_graph(edges = t(gbt_est.dupCar.mat))
# more coding
if (is_dag(gbt_est.dupCar.dgraph))
{
fit = topo_sort(gbt_est.dupCar.dgraph)
gbt_est.dupCar.irank = as.integer(names(fit))
} else {
#fit = apply(Qmat,1,sum)[gbt_est.dupCar]
fit = apply(Qmat[gbt_est.dupCar,gbt_est.dupCar],1,sum)
gbt_est.dupCar.irank = gbt_est.dupCar[order(fit, decreasing = T)]
}
gbt_est.dupCar.assingRank =
(gbt_est.dupRank[i]):(gbt_est.dupRank[i]+ length(gbt_est.dupCar)-1)
gbt_est.copy[gbt_est.dupCar] =
gbt_est.dupCar.assingRank[match(gbt_est.dupCar.irank, gbt_est.dupCar)]
}
}
return( gbt_est = gbt_est.copy )
}
gbt_est = NULL
tmp<-sc_list
tmp <-tmp[tmp[,1]!=0, 1:4]
p_set <-unique(c(tmp[,1:2]))
if (length(p_set) != p)
{
gbt_est = NULL
cat('gbt_est is NULL!')
return( gbt_est )
}
x <- matrix(0, nrow(tmp)*2, p)
y <- rep(0, nrow(tmp)*2)
for ( i in 1:nrow(tmp))
{
vec1<-tmp[i,1:2]; vec2<- tmp[i,3]
x[2*(i-1)+1, vec1] <- c(1,-1) ; y[2*(i-1)+1] <- vec2
x[2*i, vec1] <- c(-1,1) ; y[2*i] <- abs(vec2 - 1)
}
x<- x[,-p]
w = rep(tmp[,4], each = 2)
fit<-glmnet(x,y, weights = w, family = method, lambda = 0)
gbt_est <- c(fit$beta[,1],0)
names(gbt_est) = colnames(Qpmat)
return(gbt_est)
}
sr1_est = gbtFun_recov(result, Qmat_fit, method='count', allowties = T)
sr1_est
gbtFun_recov(result, Qmat_fit, method='count', allowties = F)
gbtFun_recov = function(result, Qmat_fit, method = 'binomial',
allowties = FALSE)
{
sc_list <- result
Qmat = Qmat_fit$Qmat
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
p = ncol(Qpmat)
if (method == "count")
{
mat = matrix(0,p,p);
for (i in 1:nrow(result))
{
j = result[i,1];
k = result[i,2];
w_jk = result[i,3];
if (j == 0)
{
mat[j,k] = 0.5;
mat[k,j] = 0.5;
next;
}
if (w_jk==1) mat[j,k] = 1  else mat[k,j] = 1;
}
gbt_est = apply(mat,1,sum);
gbt_est = gbt_est.copy = rank(gbt_est, ties = 'max')
gbt_est.unique = unique(gbt_est)
if (!allowties & length(gbt_est.unique) != p)
{
gbt_est.table = table(gbt_est)
gbt_est.table.names= names(gbt_est.table)
gbt_est.dupRank =
as.integer(gbt_est.table.names[which(gbt_est.table>=2)])
for (i in 1:length(gbt_est.dupRank))
{
gbt_est.dupCar = which(gbt_est == gbt_est.dupRank[i])
# gbt_est.dupCar is always sorted by which function
gbt_est.dupCar.mat = pair_fun(gbt_est.dupCar)
for (j in 1:nrow(gbt_est.dupCar.mat))
{
j1 = gbt_est.dupCar.mat[j,1]
j2 = gbt_est.dupCar.mat[j,2]
idx = result[,1]==j1 & result[,2]==j2
if (any(idx))
{
if (result[idx,3] == 0) gbt_est.dupCar.mat[j,] = c(j2, j1)
} else {
gbt_est.dupCar.mat[j,] = NA
next
}
}
gbt_est.dupCar.mat = gbt_est.dupCar.mat[!is.na(gbt_est.dupCar.mat[,1]),,drop = FALSE]
gbt_est.dupCar.mat = matrix(as.character(gbt_est.dupCar.mat),,ncol(gbt_est.dupCar.mat))
gbt_est.dupCar.dgraph = make_graph(edges = t(gbt_est.dupCar.mat))
# more coding
if (is_dag(gbt_est.dupCar.dgraph))
{
fit = topo_sort(gbt_est.dupCar.dgraph)
gbt_est.dupCar.irank = as.integer(names(fit))
} else {
#fit = apply(Qmat,1,sum)[gbt_est.dupCar]
fit = apply(Qmat[gbt_est.dupCar,gbt_est.dupCar],1,sum)
gbt_est.dupCar.irank = gbt_est.dupCar[order(fit, decreasing = T)]
}
gbt_est.dupCar.assingRank =
(gbt_est.dupRank[i]):(gbt_est.dupRank[i]-length(gbt_est.dupCar)+1)
gbt_est.copy[gbt_est.dupCar] =
gbt_est.dupCar.assingRank[match(gbt_est.dupCar.irank, gbt_est.dupCar)]
}
}
return( gbt_est = gbt_est.copy )
}
gbt_est = NULL
tmp<-sc_list
tmp <-tmp[tmp[,1]!=0, 1:4]
p_set <-unique(c(tmp[,1:2]))
if (length(p_set) != p)
{
gbt_est = NULL
cat('gbt_est is NULL!')
return( gbt_est )
}
x <- matrix(0, nrow(tmp)*2, p)
y <- rep(0, nrow(tmp)*2)
for ( i in 1:nrow(tmp))
{
vec1<-tmp[i,1:2]; vec2<- tmp[i,3]
x[2*(i-1)+1, vec1] <- c(1,-1) ; y[2*(i-1)+1] <- vec2
x[2*i, vec1] <- c(-1,1) ; y[2*i] <- abs(vec2 - 1)
}
x<- x[,-p]
w = rep(tmp[,4], each = 2)
fit<-glmnet(x,y, weights = w, family = method, lambda = 0)
gbt_est <- c(fit$beta[,1],0)
names(gbt_est) = colnames(Qpmat)
return(gbt_est)
}
gbtFun_recov(result, Qmat_fit, method='count', allowties = F)
sr1_est = gbtFun_recov(result, Qmat_fit, method='count', allowties = F)
evalFun_3(Qmat_fit, sr1_est)
result = gbt_fit$sc_list
gbt_est = gbtFun_recov(result, Qmat_fit, method = 'count', allowties = F)
gbt_est
evalFun_3_pair(gbt_fit$sc_list, Qmat_fit)
evalFun_3_pair(sr1_fun(Qmat_fit), Qmat_fit)
evalFun_3_pair(sr2_fun(Qmat_fit), Qmat_fit)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
result = sr1_fun(Qmat_fit)
sr1_est = gbtFun_recov(result, Qmat_fit, method='count', allowties = F)
evalFun_3(Qmat_fit, sr1_est)
gbtFun_recov = function(result, Qmat_fit, method = 'binomial',
allowties = FALSE)
{
sc_list <- result
Qmat = Qmat_fit$Qmat
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
p = ncol(Qpmat)
if (method == "count")
{
mat = matrix(0,p,p);
for (i in 1:nrow(result))
{
j = result[i,1];
k = result[i,2];
w_jk = result[i,3];
if (j == 0)
{
mat[j,k] = 0.5;
mat[k,j] = 0.5;
next;
}
if (w_jk==1) mat[j,k] = 1  else mat[k,j] = 1;
}
gbt_est = apply(mat,1,sum);
gbt_est = gbt_est.copy = rank(gbt_est, ties = 'max')
gbt_est.unique = unique(gbt_est)
if (!allowties & length(gbt_est.unique) != p)
{
gbt_est.table = table(gbt_est)
gbt_est.table.names= names(gbt_est.table)
gbt_est.dupRank =
as.integer(gbt_est.table.names[which(gbt_est.table>=2)])
for (i in 1:length(gbt_est.dupRank))
{
gbt_est.dupCar = which(gbt_est == gbt_est.dupRank[i])
# gbt_est.dupCar is always sorted by which function
gbt_est.dupCar.mat = pair_fun(gbt_est.dupCar)
for (j in 1:nrow(gbt_est.dupCar.mat))
{
j1 = gbt_est.dupCar.mat[j,1]
j2 = gbt_est.dupCar.mat[j,2]
idx = result[,1]==j1 & result[,2]==j2
if (any(idx))
{
if (result[idx,3] == 0) gbt_est.dupCar.mat[j,] = c(j2, j1)
} else {
gbt_est.dupCar.mat[j,] = NA
next
}
}
gbt_est.dupCar.mat = gbt_est.dupCar.mat[!is.na(gbt_est.dupCar.mat[,1]),,drop = FALSE]
gbt_est.dupCar.mat = matrix(as.character(gbt_est.dupCar.mat),,ncol(gbt_est.dupCar.mat))
gbt_est.dupCar.dgraph = make_graph(edges = t(gbt_est.dupCar.mat))
# more coding
if (is_dag(gbt_est.dupCar.dgraph))
{
fit = topo_sort(gbt_est.dupCar.dgraph)
gbt_est.dupCar.irank = as.integer(names(fit))
} else {
fit = apply(Qmat,1,sum)[gbt_est.dupCar]
#fit = apply(Qmat[gbt_est.dupCar,gbt_est.dupCar],1,sum)
gbt_est.dupCar.irank = gbt_est.dupCar[order(fit, decreasing = T)]
}
gbt_est.dupCar.assingRank =
(gbt_est.dupRank[i]):(gbt_est.dupRank[i]-length(gbt_est.dupCar)+1)
gbt_est.copy[gbt_est.dupCar] =
gbt_est.dupCar.assingRank[match(gbt_est.dupCar.irank, gbt_est.dupCar)]
}
}
return( gbt_est = gbt_est.copy )
}
gbt_est = NULL
tmp<-sc_list
tmp <-tmp[tmp[,1]!=0, 1:4]
p_set <-unique(c(tmp[,1:2]))
if (length(p_set) != p)
{
gbt_est = NULL
cat('gbt_est is NULL!')
return( gbt_est )
}
x <- matrix(0, nrow(tmp)*2, p)
y <- rep(0, nrow(tmp)*2)
for ( i in 1:nrow(tmp))
{
vec1<-tmp[i,1:2]; vec2<- tmp[i,3]
x[2*(i-1)+1, vec1] <- c(1,-1) ; y[2*(i-1)+1] <- vec2
x[2*i, vec1] <- c(-1,1) ; y[2*i] <- abs(vec2 - 1)
}
x<- x[,-p]
w = rep(tmp[,4], each = 2)
fit<-glmnet(x,y, weights = w, family = method, lambda = 0)
gbt_est <- c(fit$beta[,1],0)
names(gbt_est) = colnames(Qpmat)
return(gbt_est)
}
sr1_est = gbtFun_recov(result, Qmat_fit, method='count', allowties = F)
evalFun_3(Qmat_fit, sr1_est)
gbt_est = gbtFun_recov(result, Qmat_fit, method = 'count', allowties = F)
evalFun_3(Qmat_fit, gbt_est)
result = gbt_fit$sc_list
gbt_est = gbtFun_recov(result, Qmat_fit, method = 'count', allowties = F)
evalFun_3(Qmat_fit, gbt_est)
