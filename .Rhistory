45*16
heat.colors(300)
unique(heat.colors(300))
strsplit(“abc.b”, split = “\\.”)
strsplit('abc.b', split = '\\.')
is.na(3)
rm(list = ls())
matrix(sample(c(1,-1),100, replace = T), 10, 10)
x1 = matrix(sample(c(1,-1),100, replace = T), 10, 10)
x2 = c(sample(2:9,1), sample(2:9,1))
x2
x1[(x2[1]-1):(x2[1]+1), (x2[2]-1):(x2[2]+1)]
sum(x1[(x2[1]-1):(x2[1]+1), (x2[2]-1):(x2[2]+1)])
sign(sum(x1[(x2[1]-1):(x2[1]+1), (x2[2]-1):(x2[2]+1)]))
y = sign(sum(x1[(x2[1]-1):(x2[1]+1), (x2[2]-1):(x2[2]+1)]))
2000*70
2000*70/1000
70/200
40*10
40*10*10
2.5*24
200/200
10*2.5
10*0.25
10*24
10*24/4
180*6
# python nltk package used stopword dic
# R tm package stopwords
install.packages("tm")
180*3
180*3*4
16*1000
16*1000/3600
16*1000/3600
16*180
4*250
16*180
16*180/5
16*180/5/8
1600
800
2400 + 16*180
16*180
180*8
0.8*450
180*8
180*8*2
250*4
180*8
450*1.2
4*450
4*250
16*180
450*1.2
450*1.2+ 8*180
450*4+ 4*250 + 16 *180
450 *4
450 *4 + 250 *4
450 *4 + 250 *4 + 180*8
450 *4 + 250 *4 + 180*16
5680*0.15
rm(list = ls())
gc(reset = T)
if(!require(data.table)) install.packages("data.table")
if(!require(dplyr)) install.packages("dplyr")
require(data.table)
require(dplyr)
args = commandArgs(TRUE)
if (length(args)==0) {
stop("At least one argument must be supplied (input file).\n", call.=FALSE)
} else {
print("args-----")
mem_input_filename <- args[1]
mem_output_filename <- args[2]
print(mem_input_filename)
print(mem_output_filename)
}
mem_output_filename = gsub('.csv', '', mem_output_filename)
450*0.5
450*4 + 250*4 + 180*16
(450*4 + 250*4 + 180*16 )*0.26
(450*4 + 250*4 + 180*16 )*0.25
360 + 125
5680-1476
225*8
4204-1800
2400/8
300/6
225*0.75
]y]'y];y;r'h;o'cdlc;lc'z[ s ]
's'
''
18/48
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
sel_idx = which(BT_est_rank <=13)
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec <- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
# pair 별로 추정이 잘 되는가?
sr1_fun = function(Qmat_fit)
{
Gmat = Qmat_fit$Gmat_hat
Qmat = Qmat_fit$Qmat
Wmat = Qmat_fit$Wmat
p = nrow(Gmat)
result = matrix(0, p*(p-1)/2, 4)
i = 1
j = 8
idx = 1
for ( i in 1:(p-1))
{
for (j in (i+1):p)
{
n1 = Qmat[i,] ; n2 = Qmat[j,] ; v1 = Gmat[i,] ; v2 = Gmat[j,]
withvec = n1*n2 != 0
if ((Qmat[i,j] == 0) & (sum(withvec)==0))
{
idx = idx + 1
next
}
if (Qmat[i,j] == 0)
{
wr1 = mean(v1[withvec])
wr2 = mean(v2[withvec])
}
if (Qmat[i,j] != 0)
{
withvec[c(i,j)] = TRUE
wr1 = sum(v1[withvec])/(length(v1[withvec])-1)
wr2 = sum(v2[withvec])/(length(v2[withvec])-1)
}
result[idx, 1:3] = c(i,j, as.integer(wr1 > wr2) )
idx = idx + 1
}
}
result
}
# pair
sr2_fun = function(Qmat_fit)
{
Gmat = Qmat_fit$Gmat_hat
Qmat = Qmat_fit$Qmat
Wmat = Qmat_fit$Wmat
p = nrow(Gmat)
result = matrix(0, p*(p-1)/2, 4)
i = 1
j = 2
idx = 1
for ( i in 1:(p-1))
{
for (j in (i+1):p)
{
n1 = Qmat[i,] ; n2 = Qmat[j,] ; v1 = Wmat[i,] ; v2 = Wmat[j,]
wr1 = sum(v1)/sum(n1)
wr2 = sum(v2)/sum(n2)
result[idx, 1:3] = c(i,j, as.integer(wr1 > wr2) )
idx = idx + 1
}
}
result
}
evalFun_3_pair = function(result, Qmat_fit)
{
Gmat_hat = Qmat_fit$Gmat_hat
Qmat = Qmat_fit$Qmat
p = ncol(Qmat)
idx = 1
for (i in 1:(p-1))
{
for ( j in (i+1):p)
{
if (result[idx,1] == 0)
{
Gmat_hat[i,j] = Gmat_hat[j,i] = NA
idx = idx + 1
next
}
if ( result[idx,3] == 0) Gmat_hat[i,j] = NA else Gmat_hat[j,i] = NA
idx = idx + 1
}
}
Gmat_hat[Qmat==0] = NA
sum(Gmat_hat, na.rm = T)/sum(!is.na(Gmat_hat))
}
###########################################################
result1 = sr1_fun(Qmat_fit)
result2 = sr2_fun(Qmat_fit)
gbt_fit <- gbtFun(Qmat_fit, cvec = 0)
result4 = gbt_fit$sc_list
evalFun_3_pair(result4, Qmat_fit)
# check recover
result1[,4] = 1
sc_list <- result1
gbt_est = NULL
tmp<-sc_list
tmp <-tmp[tmp[,1]!=0, 1:4]
p_set <-unique(c(tmp[,1:2]))
if (length(p_set) != p)
{
gbt_est = NULL
cat('gbt_est is NULL!\n')
return( list(sc_list = sc_list, gbt_est = gbt_est) )
}
x <- matrix(0, nrow(tmp)*2, p)
y <- rep(0, nrow(tmp)*2)
for ( i in 1:nrow(tmp))
{
vec1<-tmp[i,1:2]; vec2<- tmp[i,3]
x[2*(i-1)+1, vec1] <- c(1,-1) ; y[2*(i-1)+1] <- vec2
x[2*i, vec1] <- c(-1,1) ; y[2*i] <- abs(vec2 - 1)
}
x<- x[,-p]
w = rep(tmp[,4], each = 2)
fit<-glmnet(x,y, weights = w, family = 'binomial', lambda = 0.000001)
gbt_est <- c(fit$beta[,1],0)
names(gbt_est) = colnames(Qmat)
gbt_est
evalFun_3(Qmat_fit, gbt_est)
## check the naive
# compare the result of SR1 and gBT-pre
tmp = cbind(result1[,1:2], result1[,3], result4[,3])
idx = (result1[,3]!=result4[,3])
tmp[idx,]
cvec=0
Qmat = Qmat_fit$Qmat
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
sc_list = list()
p = ncol(Qpmat)
idx = 1
result = matrix(0, p*(p-1)/2, 4)
i1 = 2
i2 = 11
Qpmat.c1 = Qpmat
idx1 <- ( Qpmat.c1[i1,] <= cvec )
idx2 <- ( Qpmat.c1[i2,] <= cvec )
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
## thresholding procedure
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec)
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]  ## Qpmat.c2 : symm matrix
# extend graph
#idx3 <- sort( union(intersect( setdiff(1:p, idx1), setdiff(1:p, idx2) ),  c(i1, i2)) )
## find V_jk(maximum connected set)
i1i2_adj_matrix = matrix(as.integer(Qpmat.c2>0) , p , p)  ## adjacency matrix
i1i2_graph = graph_from_adjacency_matrix(i1i2_adj_matrix ,
mode="undirected" , weighted=NULL)
## make a graph
i1i2_clusters = clusters(i1i2_graph)$mem ## clustering using adj matrix
if (i1i2_clusters[i1] != i1i2_clusters[i2]){
## i1과 i2가 다른 connected 되지 않은 경우
#  cat('   k:',k-1,', ',i1,'and',i2, 'is not connected!!\n')
idx = idx + 1
next
}
## idx3 : edge index set of V_jk
idx3 = sort(which(i1i2_clusters %in% i1i2_clusters[i1]))
#########################################
## computing gBT estimator
#########################################
#########################################
## computing gBT estimator
#########################################
# j1_mat = Qpmat.c2[c(i1,i2),]
# if (j1_mat[1,i2]!=0)
# {
#   a1 = j1_mat[1,i2]
#   a2 = max(j1_mat[1,][j1_mat[1,]!=0])
#   if (a1<a2) Qpmat.c2[i1,i2] = Qpmat.c2[i2,i1] = a2
# }
Qpmat.c2[c(i1,i2),]
#########################################
## computing gBT estimator
#########################################
# j1_mat = Qpmat.c2[c(i1,i2),]
# if (j1_mat[1,i2]!=0)
# {
#   a1 = j1_mat[1,i2]
#   a2 = max(j1_mat[1,][j1_mat[1,]!=0])
#   if (a1<a2) Qpmat.c2[i1,i2] = Qpmat.c2[i2,i1] = a2
# }
Qpmat.c2[c(i1,i2),]
#########################################
## computing gBT estimator
#########################################
# j1_mat = Qpmat.c2[c(i1,i2),]
# if (j1_mat[1,i2]!=0)
# {
#   a1 = j1_mat[1,i2]
#   a2 = max(j1_mat[1,][j1_mat[1,]!=0])
#   if (a1<a2) Qpmat.c2[i1,i2] = Qpmat.c2[i2,i1] = a2
# }
max(Qpmat.c2[c(i1,i2),])
#########################################
## computing gBT estimator
#########################################
# j1_mat = Qpmat.c2[c(i1,i2),]
# if (j1_mat[1,i2]!=0)
# {
#   a1 = j1_mat[1,i2]
#   a2 = max(j1_mat[1,][j1_mat[1,]!=0])
#   if (a1<a2) Qpmat.c2[i1,i2] = Qpmat.c2[i2,i1] = a2
# }
a = max(Qpmat.c2[c(i1,i2),])
Qpmat.c2[c(i1,i2),]
Qpmat.c2[c(i1,i2),]!=0
Qpmat.c2[c(i1,i2),][Qpmat.c2[c(i1,i2),]!=0]
Qpmat.c2[c(i1,i2),][Qpmat.c2[c(i1,i2),]!=0] = a
Qpmat.c2
Qpmat.c2[c(i1,i2),]
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
#sel_idx = sel_idx[!sel_idx==8]
#sel_idx = sel_idx[!sel_idx==20]
#sel_idx = sel_idx[!sel_idx==34]
#sel_idx = sel_idx[!sel_idx==38]
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[2])$gbt_est
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
#sel_idx = sel_idx[!sel_idx==8]
#sel_idx = sel_idx[!sel_idx==20]
#sel_idx = sel_idx[!sel_idx==34]
#sel_idx = sel_idx[!sel_idx==38]
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[2])$gbt_est
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
#sel_idx = sel_idx[!sel_idx==8]
#sel_idx = sel_idx[!sel_idx==20]
#sel_idx = sel_idx[!sel_idx==34]
#sel_idx = sel_idx[!sel_idx==38]
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[2])$gbt_est
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
#sel_idx = sel_idx[!sel_idx==8]
#sel_idx = sel_idx[!sel_idx==20]
#sel_idx = sel_idx[!sel_idx==34]
#sel_idx = sel_idx[!sel_idx==38]
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[1])$gbt_est
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
rm(list = ls())
setwd('C:/Users/Jeon/Documents/GitHub/RankConsistency')
load("Real_BT_gBT2_cv5_all_data.rdata")
gBT2_est_rank
BT_est_rank
#which(BT_est_rank==9)
#gBT2_est_rank[40]
#which(BT_est_rank==4)
#gBT2_est_rank[12]
sel_idx = which(BT_est_rank <=13)
#sel_idx = sel_idx[!sel_idx==8]
#sel_idx = sel_idx[!sel_idx==20]
#sel_idx = sel_idx[!sel_idx==34]
#sel_idx = sel_idx[!sel_idx==38]
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
# data preprocessing
race_mat <- as.matrix(rdata[,18:33])
num_vec<- rdata$V1
Qmat_fit <-QmatFun(race_mat, num_vec, p=43, sel_idx)
bt_est <- btFun(Qmat_fit)
u = sort(unique(c(Qmat_fit$Qpmat)))
gbt_est <- gbtFun(Qmat_fit, cvec = u[1])$gbt_est
evalFun_1(rdata, bt_est, sel_idx)
evalFun_1(rdata, gbt_est, sel_idx)
evalFun_2(rdata, bt_est, sel_idx)
evalFun_2(rdata, gbt_est, sel_idx)
evalFun_3(Qmat_fit, bt_est)
evalFun_3(Qmat_fit, gbt_est)
