Qpmat.c1[i1,]
cvec[k]
( Qpmat.c1[i1,] <= cvec[k] )
Qpmat.c1[i1,]==0
idx1 <- ( Qpmat.c1[i1,] <= cvec[k] )
idx2 <- ( Qpmat.c1[i2,] <= cvec[k] )
idx1
idx2
sum(idx1)>0
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
Qpmat.c2*(Qpmat.c2>cvec[k])
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec[k])
Qpmat.c2
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]  ## Qpmat.c2 : symm matrix
i1i2_adj_matrix = matrix(as.integer(Qpmat.c2>0) , p , p)  ## adjacency matrix
i1i2_graph = graph_from_adjacency_matrix(i1i2_adj_matrix ,
mode="undirected" , weighted=NULL) ## make a graph
i1i2_clusters = clusters(i1i2_graph)$mem ## clustering using adj matrix
if (i1i2_clusters[i1] != i1i2_clusters[i2]){  ## i1과 i2가 다른 connected 되지 않은 경우
#  cat('   k:',k-1,', ',i1,'and',i2, 'is not connected!!\n')
idx = idx + 1
next
}
idx3 = sort(which(i1i2_clusters %in% i1i2_clusters[i1]))
idx3
wmat <- Qpmat.c2[idx3,idx3]*Gmat_hat[idx3, idx3]
wmat = t(wmat)
pp <- length(idx3)
pp
wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
idx3
length(idx3)
colSums(is.na(n_mat))
idx3
idx3
i1i2_clusters
i1i2_clusters
i1i2_clusters[i1]
i1i2_clusters
i1i2_clusters
i1i2_clusters[i1]
which(i1i2_clusters %in% i1i2_clusters[i1])
i1i2_clusters
i1i2_clusters
i1i2_clusters[i1]
i1i2_clusters %in% i1i2_clusters[i1]
wmat
wvec
wmat <- Qpmat.c2[idx3,idx3]*Gmat_hat[idx3, idx3]
wmat = t(wmat)
pp <- length(idx3)
wvec = wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
wvec
Gmat_hat
Gmat_hat[1,]
wvec[1:43]
(1 + ( 0:(pp-1) ) *(pp+1))
wmat
xx
wmat <- Qpmat.c2[idx3,idx3]*Gmat_hat[idx3, idx3]
wmat = t(wmat)
pp <- length(idx3)
wvec = wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
xx = matrix(0, pp*(pp-1), pp)
yy = rep(0, pp*(pp-1) )
ix = 1
for (i in 1:pp)
{
for (j in 1:pp)
{
if (i == j) next
jx1 = min(i,j)
jx2 = max(i,j)
xx[ix,jx1] = 1; xx[ix,jx2] = -1
if (i<j) yy[ix] = 1
ix = ix + 1
}
}
xx = xx[,-pp]
xx
dim(xx)
i1 = 1 ; i2 = 2
idx = 1
result = matrix(0, p*(p-1)/2, 4)
for ( i1 in 1:(p-1))
{
i2 = 43
Qpmat.c1 = Qpmat
idx1 <- ( Qpmat.c1[i1,] <= cvec[k] )
idx2 <- ( Qpmat.c1[i2,] <= cvec[k] )
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
## thresholding procedure
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec[k])
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]  ## Qpmat.c2 : symm matrix
#idx3 <- sort( union(intersect( setdiff(1:p, idx1), setdiff(1:p, idx2) ),  c(i1, i2)) )
## find V_jk(maximum connected set)
i1i2_adj_matrix = matrix(as.integer(Qpmat.c2>0) , p , p)  ## adjacency matrix
i1i2_graph = graph_from_adjacency_matrix(i1i2_adj_matrix ,
mode="undirected" , weighted=NULL) ## make a graph
i1i2_clusters = clusters(i1i2_graph)$mem ## clustering using adj matrix
if (i1i2_clusters[i1] != i1i2_clusters[i2]){  ## i1과 i2가 다른 connected 되지 않은 경우
#  cat('   k:',k-1,', ',i1,'and',i2, 'is not connected!!\n')
idx = idx + 1
next
}
## idx3 : edge index set of V_jk
idx3 = sort(which(i1i2_clusters %in% i1i2_clusters[i1]))
#########################################
## computing gBT estimator
#########################################
wmat <- Qpmat.c2[idx3,idx3]*Gmat_hat[idx3, idx3]
wmat = t(wmat)
pp <- length(idx3)
wvec = wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
xx = matrix(0, pp*(pp-1), pp)
yy = rep(0, pp*(pp-1) )
ix = 1
for (i in 1:pp)
{
for (j in 1:pp)
{
if (i == j) next
jx1 = min(i,j)
jx2 = max(i,j)
xx[ix,jx1] = 1; xx[ix,jx2] = -1
if (i<j) yy[ix] = 1
ix = ix + 1
}
}
xx = xx[,-pp]
try.fit <- try(fit <- glmnet(xx, yy, family = 'binomial',
intercept = FALSE, weights = wvec,
lambda = 0.0001, alpha = 0, standardize = F,
thresh = 1e-09),
silent = T)
if (class(try.fit)[1] == 'try-error')
{
idx = idx + 1
next
}
est = c(fit$beta[,1],0)
result[idx, 1:2] = c(i1, i2)
if( est[which(idx3==i1)] > est[which(idx3==i2)]) result[idx, 3] = 1
idx = idx + 1
}
}
result[1:43,]
result[1:42,]
colSums(result[1:42,])
for ( k in 1:length(cvec))
{
#cat('thershold::', k-1, '\n')
i1 = 1 ; i2 = 2
idx = 1
result = matrix(0, p*(p-1)/2, 4)
for ( i1 in 1:(p-1))
{
i2 = 43
Qpmat.c1 = Qpmat
idx1 <- ( Qpmat.c1[i1,] <= cvec[k] )
idx2 <- ( Qpmat.c1[i2,] <= cvec[k] )
if (sum(idx1)>0 )
{
Qpmat.c1[i1,idx1] <- 0 ;  Qpmat.c1[idx1,i1] <- 0
}
if (sum(idx2)>0 )
{
Qpmat.c1[i2,idx2] <- 0 ;  Qpmat.c1[idx2,i2] <- 0
}
Qpmat.c2 = Qpmat.c1
## thresholding procedure
Qpmat.c2 = Qpmat.c2*(Qpmat.c2>cvec[k])
nvec1 = Qpmat.c1[i1,]
nvec2 = Qpmat.c1[i2,]
idx1 = which(nvec1 == 0 | nvec2 == 0)
idx2  =  setdiff( idx1, c(i1, i2))
nvec3 = (nvec1[-idx1]+nvec2[-idx1])/2
Qpmat.c2[i1,-idx1] = Qpmat.c2[i2,-idx1] = nvec3
if (length(idx2)>0)  Qpmat.c2[i1,idx2] =  Qpmat.c2[i2,idx2] = 0
Qpmat.c2[,i1] <- Qpmat.c2[i1,]
Qpmat.c2[,i2] <- Qpmat.c2[i2,]  ## Qpmat.c2 : symm matrix
#idx3 <- sort( union(intersect( setdiff(1:p, idx1), setdiff(1:p, idx2) ),  c(i1, i2)) )
## find V_jk(maximum connected set)
i1i2_adj_matrix = matrix(as.integer(Qpmat.c2>0) , p , p)  ## adjacency matrix
i1i2_graph = graph_from_adjacency_matrix(i1i2_adj_matrix ,
mode="undirected" , weighted=NULL) ## make a graph
i1i2_clusters = clusters(i1i2_graph)$mem ## clustering using adj matrix
if (i1i2_clusters[i1] != i1i2_clusters[i2]){  ## i1과 i2가 다른 connected 되지 않은 경우
#  cat('   k:',k-1,', ',i1,'and',i2, 'is not connected!!\n')
idx = idx + 1
next
}
## idx3 : edge index set of V_jk
idx3 = sort(which(i1i2_clusters %in% i1i2_clusters[i1]))
#########################################
## computing gBT estimator
#########################################
wmat <- Qpmat.c2[idx3,idx3]*Gmat_hat[idx3, idx3]
wmat = t(wmat)
pp <- length(idx3)
wvec = wmat[ - (1 + ( 0:(pp-1) ) *(pp+1))]
xx = matrix(0, pp*(pp-1), pp)
yy = rep(0, pp*(pp-1) )
ix = 1
for (i in 1:pp)
{
for (j in 1:pp)
{
if (i == j) next
jx1 = min(i,j)
jx2 = max(i,j)
xx[ix,jx1] = 1; xx[ix,jx2] = -1
if (i<j) yy[ix] = 1
ix = ix + 1
}
}
xx = xx[,-pp]
try.fit <- try(fit <- glmnet(xx, yy, family = 'binomial',
intercept = FALSE, weights = wvec,
lambda = 0, alpha = 0, standardize = F,
thresh = 1e-09),
silent = T)
if (class(try.fit)[1] == 'try-error')
{
idx = idx + 1
next
}
est = c(fit$beta[,1],0)
result[idx, 1:2] = c(i1, i2)
if( est[which(idx3==i1)] > est[which(idx3==i2)]) result[idx, 3] = 1
idx = idx + 1
}
}
colSums(result[1:42,])
result[1:42,]
source('./lib/real_lib.R')
sc_list <- sc_listFun(cvec, Qpmat, Gmat_hat)
gbt_fit <- gbt_eval(sc_list, race_mat_test = NULL, num_vec_test = NULL, cvec,
return_list = FALSE)
plot(44-rank(gbt_fit$gbt_est_mat[1,]) , 44-rank(naive_est), pch = 19,
col = heat.colors(43)[rank(apply(Qpmat,1,sum))]  )
gbt_fit
bt_est
race_mat_test<- rdata[,18:33])
race_mat_test<- rdata[,18:33]
num_vec_test <- rdata$V1
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
QmatFunc(race_mat_test, num_vec_test)
num_vec_test
race_mat_test
QmatFunc
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
QmatFunc()
QmatFunc
rdata$V1
QmatFunc
n_mat <- matrix(0, 43, 43)  ## n_mat_jk : j,k 차종의 비교 수(symm mat)
w_mat <- matrix(0, 43, 43)  ## w_mat_jk : j,k 차종의 승리 수
race_mat = race_mat_test
num_vec_test
num_vec = num_vec_test
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
n_mat <- matrix(0, 43, 43)  ## n_mat_jk : j,k 차종의 비교 수(symm mat)
w_mat <- matrix(0, 43, 43)  ## w_mat_jk : j,k 차종의 승리 수
i=1
for (i in 1:nrow(race_mat))  ## nrow : 게임 수
{
n_v <- num_vec[i] ## n_v : i번째 게임의 참여 유저 수
p_vec<- race_mat[i,1:n_v] ## i번째 게임의 차종(순위대로..)
for (j in 1:(n_v-1))
{
for (k in (j+1):n_v)
{
if (p_vec[j] == p_vec[k]) next  ## 같은 차종이 있을 경우는 제외.
w_mat[ p_vec[j], p_vec[k] ] <- w_mat[ p_vec[j], p_vec[k] ] + 1
n_mat[ p_vec[j], p_vec[k] ] <- n_mat[ p_vec[j], p_vec[k] ] + 1
n_mat[ p_vec[k], p_vec[j] ] <- n_mat[ p_vec[j], p_vec[k] ]  ## n_mat은 symm matrix
}
}
}
i
j
n_v
p_vec
j
p_vec
k
(p_vec[j] == p_vec[k])
w_mat[ p_vec[j], p_vec[k] ]
w_mat[ p_vec[j], p_vec[k] ]
w_mat[ p_vec[j], p_vec[k] ]
w_mat
p_vec[j]
p_vec[k]
w_mat[ p_vec[j], p_vec[k] ]
w_mat[39,25]
class(w_mat)
class(p_vec)
race_mat_test<- as.matrix(rdata[,18:33])
num_vec_test <- rdata$V1
race_mat = race_mat_test
num_vec = num_vec_test
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
Qmat_fit
Qmat_fit$Qpmat
gbt_est
gbt_est  = gbt_fit$gbt_est_mat[1,]
gbt_est
naive_est
naive_est
bt_est <- naive_est
i = 1
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
obs_cars
perform_kendall = matrix(0,length(num_vec_test),3)
i = 1
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
perform_kendall = matrix(0,length(num_vec_test),3)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
}
perform_kendall = matrix(0,length(num_vec_test),2)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
}
apply(perform_kendall,2,mean, na.rm = TRUE)
kenFun
kenFun = function(obs_cars, bt_est)
{
pp = length(obs_cars)
est_coef = bt_est[obs_cars]
v = 0
i.num = 0
for(i in 1:(pp-1))
{
for (j in (i+1):pp)
{
if (est_coef[i] == est_coef[j]) next
v = v + as.integer(est_coef[i] < est_coef[j])
i.num = i.num + 1
}
}
if (i.num > 0) return (v/i.num) else return(0)
}
perform_kendall = matrix(0,length(num_vec_test),2)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
}
apply(perform_kendall,2,mean, na.rm = TRUE)
rm(list = ls())
gc()
if (Sys.info()[1] == "Linux" ) setwd("/home/jeon/Documents/Github/RankConsistency/result/real_data_0621")
if (Sys.info()[1] == "Windows" ) setwd("C:/Users/jeon/Documents/GitHub/RankConsistency/result/real_data_0621")
library(igraph)
library(MASS)
source('./lib/car_lib.R')
source('./lib/lib_rank.R')
source('./lib/sim.R')
source('./lib/real_lib.R')
require('glmnet')
rdata<-read.csv('racing_data.csv', header=F)
max_k = 1
cvec_r <- seq(0, max_k, by = 2)
file_idx = 1
inner_iter = 1
seed_v = 1
#for ( seed_v in 1:inner_iter)
#{
cat("iteration::", seed_v, '\n')
seed_v_i = (file_idx -1)*inner_iter + seed_v
set.seed(seed_v_i)
sc_list = vector(mode ='list', length = max_k)
sample_idx <- 1:nrow(rdata)
# cross validation : 여기서 sample 다시 생성해야 함!
race_mat <- as.matrix(rdata[sample_idx,18:33])   ## train set의 각 게임당 선택 차종
num_vec<- rdata$V1[sample_idx]  ## 각 게임마다 참여한 유저 수
Qmat_fit <-QmatFunc(race_mat, num_vec)
Qpmat = Qmat_fit$Qpmat
Gmat_hat = Qmat_fit$Gmat_hat
x = Qmat_fit$x
y = Qmat_fit$y
n = Qmat_fit$n
######## naive BT fit
naive_est <- naive_btFunc(x,y, Qpmat, Gmat_hat)
cvec <- cvec_r/n*2 ## cvec : threshold c vector
sc_listFun
sc_list <- sc_listFun(cvec, Qpmat, Gmat_hat)
gbt_fit <- gbt_eval(sc_list, race_mat_test = NULL, num_vec_test = NULL, cvec,
return_list = FALSE)
plot(44-rank(gbt_fit$gbt_est_mat[1,]) , 44-rank(naive_est), pch = 19,
col = heat.colors(43)[rank(apply(Qpmat,1,sum))]  )
plot(44-rank(gbt_fit$gbt_est_mat[1,]) , 44-rank(naive_est), pch = 19,
col = heat.colors(43)[rank(apply(Qpmat,1,sum))]  )
gbt_est  = gbt_fit$gbt_est_mat[1,]
bt_est <- naive_est
perform_kendall = matrix(0,length(num_vec_test),2)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
}
race_mat_test<- as.matrix(rdata[,18:33])
num_vec_test <- rdata$V1
Qmat_fit <-QmatFunc(race_mat_test, num_vec_test)
Qpmat = Qmat_fit$Qpmat
gbt_est  = gbt_fit$gbt_est_mat[1,]
bt_est <- naive_est
perform_kendall = matrix(0,length(num_vec_test),2)
# evaluation
i = 1
for (i in 1:length(num_vec_test))
{
obs_cars <- race_mat_test[i,][1:num_vec_test[i]]
rank_true <- 1:length(obs_cars)
# BT
rank_hat  <- order( bt_est[obs_cars], decreasing = T)
#perform_kendall[i,1] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,1] <- kenFun(obs_cars, bt_est)
# gBT
rank_hat  <- order( gbt_est[obs_cars], decreasing = T)
#perform_kendall[i,2] <- (1-cor(rank_true, rank_hat, method = "kendall"))/2
perform_kendall[i,2] <- kenFun(obs_cars, gbt_est)
}
apply(perform_kendall,2,mean, na.rm = TRUE)
boxplot(perform_kendall)
obs_cars
obs_cars
